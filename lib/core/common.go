package core

import (
	"embed"
	"fmt"
	"log"
	"path"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

// ====================
// General Types & Aliases
// ====================

// H is a shorthand for a generic map.
type H map[string]any

// ActionCodeGenerator defines a function that generates code for a specific action.
type ActionCodeGenerator = func(action *EmiAction, ctx MicroGenContext) (*CodeChunkCompiled, error)

// CompleteModuleGenerator defines a function that generates a module, returning virtual files.
type CompleteModuleGenerator = func(module *Emi, ctx MicroGenContext) ([]VirtualFile, error)

// MicroGenContext contains the context for code generation.
type MicroGenContext struct {
	Tags    string // Tags/features to enable or disable
	Output  string // Output file or directory
	Flags   string
	Content string
}

// VirtualFile represents a file generated by codegen.
type VirtualFile struct {
	Name         string
	MimeType     string
	Location     string
	ActualScript string
	Extension    string
}

// ====================
// Code Chunks & Tokens
// ====================

// GeneratedScriptToken represents a token in generated code (class, string, enum, etc.)
type GeneratedScriptToken struct {
	Name     string
	Value    string
	Children []GeneratedScriptToken
}

// CodeChunkCompiled represents a compiled code chunk, with metadata and dependencies.
type CodeChunkCompiled struct {
	ActualScript          []byte
	CodeChunkDependensies []CodeChunkDependency
	SuggestedFileName     string
	SuggestedExtension    string
	Tokens                []GeneratedScriptToken
	Realms                interface{}
}

// CodeChunkDependency represents a dependency (import) for a code chunk.
type CodeChunkDependency struct {
	Objects  []string // Imported objects, e.g., map, fork
	Location string   // Package/location
}

// ====================
// Template Helpers
// ====================

var CommonMap = template.FuncMap{
	"endsWithDto":       func(s string) bool { return strings.HasSuffix(s, "Dto") },
	"last":              func(x int, a interface{}) bool { return x == reflect.ValueOf(a).Len()-1 },
	"goComment":         GoComment,
	"until":             GenerateRange,
	"typescriptComment": TypescriptComment,
	"join":              strings.Join,
	"b2s":               func(b []byte) string { return string(b) },
	"trim":              strings.TrimSpace,
	"upper":             ToUpper,
	"lower":             ToLower,
	"snakeUpper":        ToSnakeUpper,
	"escape":            EscapeDoubleQuotes,
	"safeIndex":         SafeIndex,
	"hasSuffix":         strings.HasSuffix,
	"regex":             RegexReplace,
	"arr":               func(els ...any) []any { return els },
	"inc":               func(i int) int { return i + 1 },
	"fx": func(fieldName string, depth int) string {
		return fmt.Sprintf("%s[index%v].", fieldName, depth)
	},
}

// GoComment converts a string into Go-style comments, escaping */ sequences.
func GoComment(comment string) string {
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = "// " + strings.ReplaceAll(line, "*/", "* /")
	}
	return strings.Join(lines, "\n")
}

// TypescriptComment converts a string into TypeScript-style comments, escaping */ sequences.
func TypescriptComment(comment string) string {
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = strings.ReplaceAll(line, "*/", "* /")
	}
	return strings.Join(lines, "\n")
}

// GenerateRange returns a slice of ints from start to end inclusive.
func GenerateRange(start, end int) []int {
	result := make([]int, end-start+1)
	for i := range result {
		result[i] = i + start
	}
	return result
}

// EscapeDoubleQuotes escapes double quotes in a string.
func EscapeDoubleQuotes(input string) string {
	return strings.ReplaceAll(input, `"`, `\"`)
}

// SafeIndex returns true if the index is within bounds of a slice.
func SafeIndex(slice []interface{}, index int) bool {
	return index >= 0 && index < len(slice)
}

// RegexReplace applies a regular expression replacement.
func RegexReplace(input, pattern, replacement string) (string, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return "", err
	}
	return re.ReplaceAllString(input, replacement), nil
}

// ====================
// Embedded Files Utilities
// ====================

// GetAllFilenames recursively lists all files in an embedded FS.
func GetAllFilenames(fs *embed.FS, dir string) ([]string, error) {
	if dir == "" {
		dir = "."
	}

	entries, err := fs.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	var out []string
	for _, entry := range entries {
		fp := path.Join(dir, entry.Name())
		if entry.IsDir() {
			res, err := GetAllFilenames(fs, fp)
			if err != nil {
				return nil, err
			}
			out = append(out, res...)
			continue
		}
		out = append(out, fp)
	}
	return out, nil
}

// ReadEmbedFileContent reads an embedded file and returns its content as string.
func ReadEmbedFileContent(fsRef *embed.FS, path string) (string, error) {
	data, err := fsRef.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// FsEmbedToVirtualFile converts embedded files into VirtualFile structs.
func FsEmbedToVirtualFile(template *embed.FS, predir string) []VirtualFile {
	var res []VirtualFile

	files, err := GetAllFilenames(template, "")
	if err != nil {
		log.Fatalln(err)
	}

	for _, file := range files {
		if file == "index.go" { // skip internal files
			continue
		}

		content, err := ReadEmbedFileContent(template, file)
		if err != nil {
			log.Fatalln(err)
		}

		res = append(res, VirtualFile{
			Name:         file,
			Location:     predir,
			ActualScript: content,
		})
	}

	return res
}

// ====================
// URL Utilities
// ====================

// ExtractPlaceholdersInUrl extracts path placeholders from a URL (e.g., "/:id").
func ExtractPlaceholdersInUrl(url string) []string {
	re := regexp.MustCompile(`/+:([A-Za-z0-9_]+)`)
	matches := re.FindAllStringSubmatch(url, -1)

	var result []string
	for _, m := range matches {
		if len(m) > 1 {
			result = append(result, m[1])
		}
	}
	return result
}

// ====================
// YAML Parsing Utilities
// ====================

func StringToEmiAction(content string) (EmiAction, error) {
	var action EmiAction
	err := yaml.Unmarshal([]byte(content), &action)
	return action, err
}

func StringToEmiFields(content string) ([]*EmiField, error) {
	var fields []*EmiField
	err := yaml.Unmarshal([]byte(content), &fields)
	return fields, err
}

func StringToEmiHeaders(content string) ([]EmiHeader, error) {
	var headers []EmiHeader
	err := yaml.Unmarshal([]byte(content), &headers)
	return headers, err
}

func StringToEmiDto(content string) (EmiDto, error) {
	var dto EmiDto
	err := yaml.Unmarshal([]byte(content), &dto)
	return dto, err
}

func StringToEmi(content string) (Emi, error) {
	var module Emi
	err := yaml.Unmarshal([]byte(content), &module)
	return module, err
}

// Based on the emi tag on the root, we detect what is the type of compile.
func DetectEmiStringContentType(content string) (string, error) {
	var module EmiCatalog
	err := yaml.Unmarshal([]byte(content), &module)

	if err != nil {
		return "", err
	}

	if module.Emi == "dto" {
		return "dto", nil
	}

	if module.Emi == "action" {
		return "action", nil
	}

	if module.Emi == "entity" {
		return "entity", nil
	}

	// By default, it's an emit module
	return "module", nil
}

func ReadEmiFromString(content string) (*Emi, error) {
	var data Emi
	if err := yaml.Unmarshal([]byte(content), &data); err != nil {
		return nil, err
	}
	return &data, nil
}

func ReadEmiActionFromString(content string) (*EmiAction, error) {
	var data EmiAction
	if err := yaml.Unmarshal([]byte(content), &data); err != nil {
		return nil, err
	}
	return &data, nil
}

// ====================
// Claim Rendering
// ====================

// ClaimRender renders claims based on tags (TypeScript or JS)
func ClaimRender(claims []JsFnArgument, ctx MicroGenContext) map[string]string {
	rendered := make(map[string]string)
	for _, c := range claims {
		if strings.Contains(ctx.Tags, "typescript") {
			rendered[c.Key] = c.CompileTs()
		} else {
			rendered[c.Key] = c.CompileJs()
		}
	}
	return rendered
}

func IsNullable(value string) bool {
	return strings.Contains(value, "?")
}

func IsNumericDataType(value string) bool {
	switch value {
	case "int64?", "int32?", "int?", "float64?", "float32?", "int64", "int32", "int":
		return true
	default:
		return false
	}

}

// when developer says target: AnotherEntity or target: AnotherDto, we need
// to import that. Here we search through the definition tree and extract them all
func CollectTargets(fields []*EmiField) []string {
	var result []string

	var walk func(f []*EmiField)
	walk = func(f []*EmiField) {
		for _, field := range f {
			if field.Target != "" {
				result = append(result, field.Target)
			}

			if len(field.Fields) > 0 {
				walk(field.Fields)
			}
		}
	}

	walk(fields)
	return result
}

func ParseDtoPath(input string) (path string, className string) {
	if input == "" {
		return "./", ""
	}

	// normalize slashes
	input = filepath.ToSlash(input)

	dir := filepath.Dir(input)
	base := filepath.Base(input)

	if dir == "." {
		path = "./" + base
	} else {
		path = filepath.ToSlash(filepath.Join(dir, base))
	}

	className = base
	return
}
