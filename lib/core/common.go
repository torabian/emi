package core

import (
	"embed"
	"fmt"
	"log"
	"path"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

type H map[string]any

type ActionCodeGenerator = func(action *Module3Action, ctx MicroGenContext) (*CodeChunkCompiled, error)

type MicroGenContext struct {

	// Tags and features which will be enabled or disabled.
	Tags string

	// Output file or directory for generation context
	Output string
}

// Each generated file can have a set of tokens, such as classes, strings, enums, etc.
// since we cannot parse the generated code into AST (for language not go), we provide such details
// out of a generated code snipped to work on top of the other.
type GeneratedScriptToken struct {
	Name     string
	Value    string
	Children []GeneratedScriptToken
}

type CodeChunkCompiled struct {

	// The code which has been generated on the process.
	ActualScript []byte

	CodeChunkDependenies []CodeChunkDependency

	SuggestedFileName string

	SuggestedExtension string

	Tokens []GeneratedScriptToken

	Realms interface{}
}

type CodeChunkDependency struct {
	// things to import, for example import {map, fork}
	Objects []string

	// Location or package name
	Location string
}

var CommonMap = template.FuncMap{
	"endsWithDto": func(s string) bool {
		return strings.HasSuffix(s, "Dto")
	},
	"last": func(x int, a interface{}) bool {
		return x == reflect.ValueOf(a).Len()-1
	},
	"goComment":         GoComment,
	"until":             GenerateRange,
	"typescriptComment": TypescriptComment,
	"join":              strings.Join,
	"b2s":               func(b []byte) string { return string(b) },
	"trim":              strings.TrimSpace,
	"upper":             ToUpper,
	"lower":             ToLower,
	"snakeUpper":        ToSnakeUpper,
	"escape":            EscapeDoubleQuotes,
	"safeIndex":         SafeIndex,
	"hasSuffix":         strings.HasSuffix,
	"regex":             RegexReplace,
	"arr":               func(els ...any) []any { return els },
	"inc": func(i int) int {
		return i + 1
	},
	"fx": func(fieldName string, depth int) string {
		return fieldName + "[index" + fmt.Sprintf("%v", depth) + "]."
	},
}

func GoComment(comment string) string {
	// Escape problematic characters and split into lines
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = "// " + strings.ReplaceAll(line, "*/", "* /") // Escape `*/`
	}
	return strings.Join(lines, "\n")
}

func GenerateRange(start, end int) []int {
	result := make([]int, end-start+1)
	for i := range result {
		result[i] = i + start
	}
	return result
}

func TypescriptComment(comment string) string {
	// Escape problematic characters and split into lines
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = strings.ReplaceAll(line, "*/", "* /") // Escape `*/`
	}
	return strings.Join(lines, "\n")
}

func EscapeDoubleQuotes(input string) string {
	return strings.ReplaceAll(input, `"`, `\"`)
}

func SafeIndex(slice []interface{}, index int) bool {
	if index < 0 || index >= len(slice) {
		return false
	}
	return true
}

func RegexReplace(input, pattern, replacement string) (string, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return "", err
	}
	return re.ReplaceAllString(input, replacement), nil
}

// Represent a file generated by codegen
type VirtualFile struct {
	Name         string
	MimeType     string
	Location     string
	ActualScript string
	Extension    string
}

type CompleteModuleGenerator = func(module *Module3, ctx MicroGenContext) ([]VirtualFile, error)

func ClaimRender(claims []JsFnArgument, ctx MicroGenContext) map[string]string {

	claimsRendered := make(map[string]string)
	for _, c := range claims {
		if strings.Contains(ctx.Tags, "typescript") {
			claimsRendered[c.Key] = c.CompileTs()
		} else {
			claimsRendered[c.Key] = c.CompileJs()
		}
	}

	return claimsRendered

}

func GetAllFilenames(fs *embed.FS, dir string) (out []string, err error) {
	if len(dir) == 0 {
		dir = "."
	}

	entries, err := fs.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		fp := path.Join(dir, entry.Name())
		if entry.IsDir() {
			res, err := GetAllFilenames(fs, fp)
			if err != nil {
				return nil, err
			}

			out = append(out, res...)

			continue
		}

		out = append(out, fp)
	}

	return
}

func ReadEmbedFileContent(fsRef *embed.FS, path string) (string, error) {

	data, err := fsRef.ReadFile(path)

	if err != nil {
		return "", err
	}

	return string(data), nil
}

// On different languages, we need to provide sdk, prebuilt files,
// such as helpers for generated code. Embed them in go, and use this file
func FsEmbedToVirtualFile(template *embed.FS, predir string) []VirtualFile {

	// Move the include directory

	res := []VirtualFile{}

	files, err := GetAllFilenames(template, "")
	if err != nil {
		log.Fatalln(err)
	}

	for _, file := range files {

		// skip index.go files used for embedding
		if file == "index.go" {
			continue
		}

		content, err4 := ReadEmbedFileContent(template, file)
		if err4 != nil {
			log.Fatalln(err)
		}

		res = append(res, VirtualFile{
			Name:     file,
			Location: predir,

			// Extension is already in file name in this case
			// Extension:    filepath.Ext(file),
			ActualScript: content,
		})
	}

	return res

}

func ExtractPlaceholdersInUrl(url string) []string {
	re := regexp.MustCompile(`:([A-Za-z0-9_]+)`)
	matches := re.FindAllStringSubmatch(url, -1)

	var result []string
	for _, m := range matches {
		if len(m) > 1 {
			result = append(result, m[1])
		}
	}
	return result
}
