package js

import (
	"bytes"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/torabian/emi/lib/core"
)

type renderedJsHeader struct {
	PropertyName string
	Type         string
	Description  string
	GetterFunc   string
	SetterFunc   string
}

type jsHeaderClassContext struct {
	ClassName string
	Columns   []core.Module3Header
}

func normalizeJsHeaderType(value string) (string, error) {
	if IsNumericDataType(value) {
		return "number | null", nil
	}

	switch value {
	case "string":
		return "string | null", nil
	case "bool":
		return "boolean | null", nil
	}
	return "any", nil
}

func renderJsTsCommonHeadersInfo(headerColumns []core.Module3Header) ([]renderedJsHeader, error) {
	headers := []renderedJsHeader{}
	for _, header := range headerColumns {
		headerType, err := normalizeJsHeaderType(header.Type)
		if err != nil {
			return nil, err
		}
		funcName := core.ToUpper(headerNameNormalize(header.Name))
		headers = append(headers, renderedJsHeader{
			PropertyName: header.Name,
			Type:         headerType,
			Description:  header.Description,
			GetterFunc:   "get" + funcName,
			SetterFunc:   "set" + funcName,
		})
	}
	return headers, nil
}

var GEN_NEST_JS_COMPATIBILITY string = "nestjs"
var GEN_TYPESCRIPT_COMPATIBILITY string = "typescript"
var GEN_ANGULAR_COMPATIBILITY string = "angular"
var GEN_AXIOS_BUNDLE_COMPATIBILITY string = "axiosbundle"
var GEN_REACT_COMPATIBILITY string = "react"
var GEN_AXIOS_COMPATIBILITY string = "axios"

func JsHeaderClass(
	headerctx jsHeaderClassContext,
	ctx core.MicroGenContext,
) (*core.CodeChunkCompiled, error) {

	const tmpl = `/**
 * {{.className}} class
 * Auto-generated from Module3Action
 */
{{ if .shouldExport -}} export {{- end }} class {{.className}} extends Headers {

  {{- range .headers }}
  /**
   * @returns { {{.Type}} }
   * @description {{ .Description }}
   */
  {{.GetterFunc}} () {
    return this.#getTyped('{{.PropertyName}}', '{{.Type}}');
  }
  /**
   * @param { {{.Type}} } value
   * @description {{ .Description }}
   */
  {{.SetterFunc}} (value) {
    this.set('{{.PropertyName}}', value);
    return this;
  }
  {{- end }}

  {{ if .headers }}
  // the getters generated by us would be casting types before returning.
  // you still can use .get function to get the string value.
  // eslint-disable-next-line no-unused-private-class-members
  #getTyped({{ .getKeyArgument }}, {{ .getTypeArgument }}) {
    const val = this.get(key);
    if (val == null) return null;

    const t = type.toLowerCase();

    if (t.includes('number')) return Number(val);
    if (t.includes('bool')) return val === 'true';
    return val; // string or any other fallback
  }
  {{ end }}

  /**
   * @returns {Record<string, string>}
   * Converts Headers to plain object
   */
  toObject() {
    return Object.fromEntries(this.entries());
  }

  {{ if .nestjsDecorator }}
	{{ .nestJsDecoratorRendered }}
  {{ end}}
}
`
	renderedHeaders, err := renderJsTsCommonHeadersInfo(headerctx.Columns)
	if err != nil {
		return nil, err
	}
	res := &core.CodeChunkCompiled{}

	t := template.Must(template.New("headerclass").Funcs(core.CommonMap).Parse(tmpl))
	nestJsDecorator := strings.Contains(ctx.Tags, GEN_NEST_JS_COMPATIBILITY)
	isTypeScript := strings.Contains(ctx.Tags, GEN_TYPESCRIPT_COMPATIBILITY)

	getTypeArgument := "type"
	if isTypeScript {
		getTypeArgument = "type: string"
	}

	getKeyArgument := "key"
	if isTypeScript {
		getKeyArgument = "key: string"
	}

	var nestJsDecoratorRendered = ""

	if nestJsDecorator {

		nestjsStaticDecorator, err := JsNestJsStaticDecorator(NestJsStaticDecoratorContext{
			ClassInstance:               headerctx.ClassName,
			NestJsStaticFunctionUseCase: RequestHeaders,
		}, ctx)

		if err != nil {
			return nil, err
		}

		// Make sure to add dependencies to render tree
		res.CodeChunkDependenies = append(res.CodeChunkDependenies, nestjsStaticDecorator.CodeChunkDependenies...)

		// Add the static function to the class bottom
		nestJsDecoratorRendered = string(nestjsStaticDecorator.ActualScript)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, core.H{
		"nestJsDecoratorRendered": nestJsDecoratorRendered,
		"getTypeArgument":         getTypeArgument,
		"getKeyArgument":          getKeyArgument,
		"headers":                 renderedHeaders,
		"shouldExport":            true,
		"nestjsDecorator":         nestJsDecoratorRendered,
		"className":               headerctx.ClassName,
	}); err != nil {
		return nil, err
	}

	res.ActualScript = buf.Bytes()
	res.Tokens = []core.GeneratedScriptToken{
		{
			Name:  TOKEN_ROOT_CLASS,
			Value: headerctx.ClassName,
		},
	}

	return res, nil
}

var camelCaseRe = regexp.MustCompile(`^[a-z][a-zA-Z0-9]*$`)

func headerNameNormalize(s string) string {
	if camelCaseRe.MatchString(s) {
		return s
	}
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	s = re.ReplaceAllString(s, " ")
	parts := strings.Fields(s)
	if len(parts) == 0 {
		return ""
	}
	result := strings.ToLower(parts[0])
	for _, p := range parts[1:] {
		if p == "" {
			continue
		}
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		result += string(runes)
	}
	return result
}
