"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[487],{4024:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"js/emi-object","title":"Javascript object generation","description":"Every request body, request response, message on web socket, entity, dto in Emi are called \'object\'. The object is generated based on","source":"@site/docs/js/emi-object.mdx","sourceDirName":"js","slug":"/js/emi-object","permalink":"/docs/js/emi-object","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/js/emi-object.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Javascript(Type?) Compiler","permalink":"/docs/js/js-intro"}}');var i=t(4848),r=t(8453);const o={sidebar_position:3},a="Javascript object generation",c={},l=[{value:"Javascript classes vs objects",id:"javascript-classes-vs-objects",level:2},{value:"Problems with plain types",id:"problems-with-plain-types",level:3},{value:"Solution: Use Classes",id:"solution-use-classes",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"javascript-object-generation",children:"Javascript object generation"})}),"\n",(0,i.jsx)(n.p,{children:"Every request body, request response, message on web socket, entity, dto in Emi are called 'object'. The object is generated based on\nfields array, which can be nested, of course. Emi uses the same function for generting different type of classes."}),"\n",(0,i.jsx)(n.h2,{id:"javascript-classes-vs-objects",children:"Javascript classes vs objects"}),"\n",(0,i.jsx)(n.p,{children:"When working with APIs, it\u2019s tempting to just define a TypeScript type and fetch data. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'type Post = { userId: number; id: number; title: string; body: string };\n\nasync function fetchPost(id: number): Promise<Post> {\n  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);\n  return res.json();\n}\n\n// Example usage\nfetchPost(1).then(post => {\n  console.log("Title:", post.title);\n});\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"This looks fine at first glance, but it has some important problems:"}),"\n",(0,i.jsx)(n.h3,{id:"problems-with-plain-types",children:"Problems with plain types"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Backend drift\nThe backend may evolve over time. Fields might be renamed, removed, or added. Your TypeScript types won\u2019t catch this at runtime \u2014 they only exist at compile time."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["No defaults\nIf the backend omits a field, you\u2019ll end up with ",(0,i.jsx)(n.code,{children:"undefined"}),". There\u2019s no way to guarantee initialized values, which makes your code brittle."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Runtime unsafety\nEven if TypeScript says everything is fine, the actual JSON from the server might be malformed or missing required fields. TypeScript does not validate data at runtime."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"solution-use-classes",children:"Solution: Use Classes"}),"\n",(0,i.jsxs)(n.p,{children:["By wrapping responses into ",(0,i.jsx)(n.strong,{children:"classes"}),", we get:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Defaults for missing fields"}),"\n",(0,i.jsx)(n.li,{children:"Runtime-safe construction of objects"}),"\n",(0,i.jsx)(n.li,{children:"A clean place for helper methods"}),"\n",(0,i.jsx)(n.li,{children:"Extending them and embed the extra logic in single place rather than functions scattered across the app."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Take a look at the rewritten mechanism, this time using classes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'class Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n\n  constructor(data: Partial<Post>) {\n    this.userId = data.userId ?? 0;\n    this.id = data.id ?? 0;\n    this.title = data.title ?? "Untitled";\n    this.body = data.body ?? "";\n  }\n\n  static async fetch(id: number): Promise<Post> {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);\n    const json = await res.json();\n    return new Post(json);\n  }\n\n  shortBody(): string {\n    return this.body.slice(0, 50) + "...";\n  }\n}\n\n// Usage\n(async () => {\n  const post = await Post.fetch(1);\n  console.log("Title:", post.title);\n  console.log("Preview:", post.shortBody());\n})();\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now, this is much more reliable code instead of just typing them, you almost never get undefined. But still, writing that manually\nis a hassle, and type checking and other tools might be lost. Now, let's take a look how this could be generated using Emi js compiler:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- name: userId\n  type: int64\n- name: id\n  type: int64\n- name: title\n  type: string\n- name: body\n  type: string\n"})}),"\n",(0,i.jsx)(n.p,{children:"And Emi compiler would generate such shopisticated details:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'\t/**\r\n  * @description The base type definition for anonymouse\r\n  **/\r\n\texport type AnonymouseType =  {\n\t\t\t/**\r\n  * @type {number}\r\n  * @description \r\n  **/\r\n userId?: number;\n\t}\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace AnonymouseType {\n}\n/**\r\n  * @decription The base class definition for anonymouse\r\n  **/\r\nexport class Anonymouse {\n\tconstructor(data) {\n\t\t// This probably doesn\'t cover the nested objects\n\t\tconst d = data as Partial<Anonymouse>;\n\t\t\tif (d[`userId`] !== undefined) { \r\n this.setUserId (d[`userId`]) \r\n}\n\t}\n\t\t/**\r\n  * \r\n  * @type {number}\r\n  **/\r\n userId;\n\t\t/**\r\n  * @returns {number}\r\n  * @description \r\n  **/\r\ngetUserId () { return this[`userId`] }\n/**\r\n  * \r\n  * @param {number}\r\n  **/\r\nsetUserId(value: number) {\n\tthis["userId"] = value\n\treturn this\n}\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);