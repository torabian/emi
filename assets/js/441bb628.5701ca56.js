"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[800],{2354:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"js/emi-string-data-type","title":"Emi string data type","description":"Given the following example:","source":"@site/docs/js/emi-string-data-type.mdx","sourceDirName":"js","slug":"/js/emi-string-data-type","permalink":"/emi/docs/js/emi-string-data-type","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-string-data-type.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Static fields path generation","permalink":"/emi/docs/js/emi-static-fields"},"next":{"title":"Emi boolean data type","permalink":"/emi/docs/js/emi-boolean-data-type"}}');var a=e(4848),s=e(8453);const r={sidebar_position:4},l="Emi string data type",o={},u=[];function p(n){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"emi-string-data-type",children:"Emi string data type"})}),"\n",(0,a.jsx)(t.p,{children:"Given the following example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"name: MyStringClass\nfields:\n  - name: stringWithDefault\n    default: With default value\n    type: string\n  - name: emptyString\n    type: string\n\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"string"})," and ",(0,a.jsx)(t.code,{children:"string?"})," types will be converted into the javascript counter part with a difference that ? allows the null value, and by default is ",(0,a.jsx)(t.code,{children:"undefined"}),".\nAs a general pattern the field private value (#field) would be created, and based on that, there will be getters and setters."]}),"\n",(0,a.jsxs)(t.p,{children:["First let's take a look on the ",(0,a.jsx)(t.code,{children:"string"}),", and see how it would prevent the crashes by generating the typesafe code:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'/**\n * The base class definition for myStringClassDto\n **/\nexport class MyStringClassDto {\n  /**\n   *\n   * @type {string}\n   **/\n  #stringWithDefault: string = "With default value";\n  /**\n   *\n   * @returns {string}\n   **/\n  get stringWithDefault() {\n    return this.#stringWithDefault;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  set stringWithDefault(value: string) {\n    this.#stringWithDefault = String(value);\n  }\n  setStringWithDefault(value: string) {\n    this.stringWithDefault = value;\n    return this;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  #emptyString: string = "";\n  /**\n   *\n   * @returns {string}\n   **/\n  get emptyString() {\n    return this.#emptyString;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  set emptyString(value: string) {\n    this.#emptyString = String(value);\n  }\n  setEmptyString(value: string) {\n    this.emptyString = value;\n    return this;\n  }\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyStringClassDto>;\n    if (d.stringWithDefault !== undefined) {\n      this.stringWithDefault = d.stringWithDefault;\n    }\n    if (d.emptyString !== undefined) {\n      this.emptyString = d.emptyString;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      stringWithDefault: this.#stringWithDefault,\n      emptyString: this.#emptyString,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      stringWithDefault: "stringWithDefault",\n      emptyString: "emptyString",\n    };\n  }\n  /**\n   * Creates an instance of MyStringClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyStringClassDtoType) {\n    return new MyStringClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyStringClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyStringClassDtoType>) {\n    return new MyStringClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyStringClassDtoType>,\n  ): InstanceType<typeof MyStringClassDto> {\n    return new MyStringClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyStringClassDto> {\n    return new MyStringClassDto(this.toJSON());\n  }\n}\nexport abstract class MyStringClassDtoFactory {\n  abstract create(data: unknown): MyStringClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myStringClassDto\n **/\nexport type MyStringClassDtoType = {\n  /**\n   *\n   * @type {string}\n   **/\n  stringWithDefault: string;\n  /**\n   *\n   * @type {string}\n   **/\n  emptyString: string;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyStringClassDtoType {}\n\n'})}),"\n",(0,a.jsx)(t.p,{children:"Given the following example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"name: MyStringClass\nfields:\n  - name: nullableStringWithDefault\n    default: With default value\n    type: string?\n  - name: nullableWithoutDefault\n    type: string?\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"In nullable scenario, the field is initialised with 'undefined' and allows null value as well.\nIf default provided, the default value will be placed."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'/**\n * The base class definition for myStringClassDto\n **/\nexport class MyStringClassDto {\n  /**\n   *\n   * @type {string}\n   **/\n  #nullableStringWithDefault?: string | null = "With default value";\n  /**\n   *\n   * @returns {string}\n   **/\n  get nullableStringWithDefault() {\n    return this.#nullableStringWithDefault;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  set nullableStringWithDefault(value: string | null | undefined) {\n    const correctType =\n      typeof value === "string" || value === undefined || value === null;\n    this.#nullableStringWithDefault = correctType ? value : String(value);\n  }\n  setNullableStringWithDefault(value: string | null | undefined) {\n    this.nullableStringWithDefault = value;\n    return this;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  #nullableWithoutDefault?: string | null = undefined;\n  /**\n   *\n   * @returns {string}\n   **/\n  get nullableWithoutDefault() {\n    return this.#nullableWithoutDefault;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  set nullableWithoutDefault(value: string | null | undefined) {\n    const correctType =\n      typeof value === "string" || value === undefined || value === null;\n    this.#nullableWithoutDefault = correctType ? value : String(value);\n  }\n  setNullableWithoutDefault(value: string | null | undefined) {\n    this.nullableWithoutDefault = value;\n    return this;\n  }\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyStringClassDto>;\n    if (d.nullableStringWithDefault !== undefined) {\n      this.nullableStringWithDefault = d.nullableStringWithDefault;\n    }\n    if (d.nullableWithoutDefault !== undefined) {\n      this.nullableWithoutDefault = d.nullableWithoutDefault;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      nullableStringWithDefault: this.#nullableStringWithDefault,\n      nullableWithoutDefault: this.#nullableWithoutDefault,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      nullableStringWithDefault: "nullableStringWithDefault",\n      nullableWithoutDefault: "nullableWithoutDefault",\n    };\n  }\n  /**\n   * Creates an instance of MyStringClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyStringClassDtoType) {\n    return new MyStringClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyStringClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyStringClassDtoType>) {\n    return new MyStringClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyStringClassDtoType>,\n  ): InstanceType<typeof MyStringClassDto> {\n    return new MyStringClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyStringClassDto> {\n    return new MyStringClassDto(this.toJSON());\n  }\n}\nexport abstract class MyStringClassDtoFactory {\n  abstract create(data: unknown): MyStringClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myStringClassDto\n **/\nexport type MyStringClassDtoType = {\n  /**\n   *\n   * @type {string}\n   **/\n  nullableStringWithDefault?: string;\n  /**\n   *\n   * @type {string}\n   **/\n  nullableWithoutDefault?: string;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyStringClassDtoType {}\n\n'})})]})}function d(n={}){const{wrapper:t}={...(0,s.R)(),...n.components};return t?(0,a.jsx)(t,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>r,x:()=>l});var i=e(6540);const a={},s=i.createContext(a);function r(n){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(s.Provider,{value:t},n.children)}}}]);