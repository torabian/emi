"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[728],{8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),r.createElement(s.Provider,{value:e},n.children)}},9051:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"js/emi-javascript-web-socket","title":"WebSocket generation in Emi","description":"Websockets are one of the most important aspect of reactive web programming now adays, which allow sending full-duplex messages between server and front-end.","source":"@site/docs/js/emi-javascript-web-socket.mdx","sourceDirName":"js","slug":"/js/emi-javascript-web-socket","permalink":"/emi/docs/js/emi-javascript-web-socket","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-javascript-web-socket.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Class fields in depth","permalink":"/emi/docs/js/emi-fields-in-depth"},"next":{"title":"Static fields path generation","permalink":"/emi/docs/js/emi-static-fields"}}');var a=t(4848),s=t(8453);const i={sidebar_position:4},o="WebSocket generation in Emi",c={},m=[{value:"Sample 1: Json requests and json responses",id:"sample-1-json-requests-and-json-responses",level:2},{value:"Generated content",id:"generated-content",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"websocket-generation-in-emi",children:"WebSocket generation in Emi"})}),"\n",(0,a.jsx)(e.p,{children:"Websockets are one of the most important aspect of reactive web programming now adays, which allow sending full-duplex messages between server and front-end.\nYou can define an action method: 'reactive', and it would consider the endpoint is a websocket.\nEmi extends the standard WebSocket class in JavaScript, and in case of other generators (react for example), they would wrap the instance."}),"\n",(0,a.jsx)(e.p,{children:"In this document, we will generate, document and test different type of the websocket messages for javascript."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Important to note"})," that the javascript generated code, can work both in node.js and browser environment, but main focus of this\ngenerator is client side. Still, you can use the request and response classes create."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"WebSocketX"})," class is the base class which all code for js/ts will be generated on top of it. It's very similar to standard WebSocket class,\nwith exception that message and send are overriden, to accept types specificed as generic. Also the constructor, will get factory for message creation,\nin case of working with json messages."]}),"\n",(0,a.jsx)(e.h2,{id:"sample-1-json-requests-and-json-responses",children:"Sample 1: Json requests and json responses"}),"\n",(0,a.jsx)(e.p,{children:"Standard websocket allows for bytes, strings, arraybuffers to be sent on both ways. On top of that, Emi adds the option to send\ntypesafe class structure over, in following example, we are working on a socket endpoint, which would expect a message with min,max,count\nvariables, and would generate random number messages (as a json class, not primitive), and ui will print it."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:"name: socketTestingModule\nactions:\n- name: userStream\nurl: ws://localhost:8081\nmethod: reactive\ndescription: >-\nA socket connection which would generate random numbers, based on min,\nmax, and count.\nin:\nfields:\n  - name: min\n    type: int\n    description: Minimum number which can be generated\n  - name: max\n    type: int\n    description: Maximum number which can be generated\n  - name: count\n    type: int\n    description: >-\n      How many numbers you want to be generated based on maximum and\n      minimum\nout:\nfields:\n  - name: number\n    type: int\n\n"})}),"\n",(0,a.jsx)(e.h2,{id:"generated-content",children:"Generated content"}),"\n",(0,a.jsx)(e.p,{children:"Now the result is going to be a complete WebRequestX instance, with proper typings:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'import { WebSocketX } from "./sdk/common/WebSocketX";\nimport { buildUrl } from "./sdk/common/buildUrl";\nimport { withPrefix } from "./sdk/common/withPrefix";\n/**\n * Action to communicate with the action userStream\n */\nexport type UserStreamActionOptions = {\n  queryKey?: unknown[];\n  qs?: URLSearchParams;\n};\n/**\n * UserStreamAction\n */\nexport class UserStreamAction {\n  static URL = "ws://localhost:8081";\n  static NewUrl = (qs?: URLSearchParams) =>\n    buildUrl(UserStreamAction.URL, undefined, qs);\n  static Method = "reactive";\n  static Create = (overrideUrl?: string, qs?: URLSearchParams) => {\n    const url = overrideUrl ?? UserStreamAction.NewUrl(qs);\n    return new WebSocketX<UserStreamActionReq, UserStreamActionRes>(\n      url,\n      undefined,\n      {\n        MessageFactoryClass: UserStreamActionRes,\n      },\n    );\n  };\n  static Definition = {\n    name: "userStream",\n    url: "ws://localhost:8081",\n    method: "reactive",\n    description:\n      "A socket connection which would generate random numbers, based on min, max, and count.",\n    in: {\n      fields: [\n        {\n          name: "min",\n          description: "Minimum number which can be generated",\n          type: "int",\n        },\n        {\n          name: "max",\n          description: "Maximum number which can be generated",\n          type: "int",\n        },\n        {\n          name: "count",\n          description:\n            "How many numbers you want to be generated based on maximum and minimum",\n          type: "int",\n        },\n      ],\n    },\n    out: {\n      fields: [\n        {\n          name: "number",\n          type: "int",\n        },\n      ],\n    },\n  };\n}\n/**\n * The base class definition for userStreamActionReq\n **/\nexport class UserStreamActionReq {\n  /**\n   * Minimum number which can be generated\n   * @type {number}\n   **/\n  #min: number = 0;\n  /**\n   * Minimum number which can be generated\n   * @returns {number}\n   **/\n  get min() {\n    return this.#min;\n  }\n  /**\n   * Minimum number which can be generated\n   * @type {number}\n   **/\n  set min(value: number) {\n    const correctType = typeof value === "number";\n    const parsedValue = correctType ? value : Number(value);\n    if (!Number.isNaN(parsedValue)) {\n      this.#min = parsedValue;\n    }\n  }\n  setMin(value: number) {\n    this.min = value;\n    return this;\n  }\n  /**\n   * Maximum number which can be generated\n   * @type {number}\n   **/\n  #max: number = 0;\n  /**\n   * Maximum number which can be generated\n   * @returns {number}\n   **/\n  get max() {\n    return this.#max;\n  }\n  /**\n   * Maximum number which can be generated\n   * @type {number}\n   **/\n  set max(value: number) {\n    const correctType = typeof value === "number";\n    const parsedValue = correctType ? value : Number(value);\n    if (!Number.isNaN(parsedValue)) {\n      this.#max = parsedValue;\n    }\n  }\n  setMax(value: number) {\n    this.max = value;\n    return this;\n  }\n  /**\n   * How many numbers you want to be generated based on maximum and minimum\n   * @type {number}\n   **/\n  #count: number = 0;\n  /**\n   * How many numbers you want to be generated based on maximum and minimum\n   * @returns {number}\n   **/\n  get count() {\n    return this.#count;\n  }\n  /**\n   * How many numbers you want to be generated based on maximum and minimum\n   * @type {number}\n   **/\n  set count(value: number) {\n    const correctType = typeof value === "number";\n    const parsedValue = correctType ? value : Number(value);\n    if (!Number.isNaN(parsedValue)) {\n      this.#count = parsedValue;\n    }\n  }\n  setCount(value: number) {\n    this.count = value;\n    return this;\n  }\n  constructor(data: unknown) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<UserStreamActionReq>;\n    if (d.min !== undefined) {\n      this.min = d.min;\n    }\n    if (d.max !== undefined) {\n      this.max = d.max;\n    }\n    if (d.count !== undefined) {\n      this.count = d.count;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      min: this.#min,\n      max: this.#max,\n      count: this.#count,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      min: "min",\n      max: "max",\n      count: "count",\n    };\n  }\n}\nexport abstract class UserStreamActionReqFactory {\n  abstract create(data: unknown): UserStreamActionReq;\n}\n/**\n * The base type definition for userStreamActionReq\n **/\nexport type UserStreamActionReqType = {\n  /**\n   * Minimum number which can be generated\n   * @type {number}\n   **/\n  min: number;\n  /**\n   * Maximum number which can be generated\n   * @type {number}\n   **/\n  max: number;\n  /**\n   * How many numbers you want to be generated based on maximum and minimum\n   * @type {number}\n   **/\n  count: number;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace UserStreamActionReqType {}\n/**\n * The base class definition for userStreamActionRes\n **/\nexport class UserStreamActionRes {\n  /**\n   *\n   * @type {number}\n   **/\n  #number: number = 0;\n  /**\n   *\n   * @returns {number}\n   **/\n  get number() {\n    return this.#number;\n  }\n  /**\n   *\n   * @type {number}\n   **/\n  set number(value: number) {\n    const correctType = typeof value === "number";\n    const parsedValue = correctType ? value : Number(value);\n    if (!Number.isNaN(parsedValue)) {\n      this.#number = parsedValue;\n    }\n  }\n  setNumber(value: number) {\n    this.number = value;\n    return this;\n  }\n  constructor(data: unknown) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<UserStreamActionRes>;\n    if (d.number !== undefined) {\n      this.number = d.number;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      number: this.#number,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      number: "number",\n    };\n  }\n}\nexport abstract class UserStreamActionResFactory {\n  abstract create(data: unknown): UserStreamActionRes;\n}\n/**\n * The base type definition for userStreamActionRes\n **/\nexport type UserStreamActionResType = {\n  /**\n   *\n   * @type {number}\n   **/\n  number: number;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace UserStreamActionResType {}\n\n'})})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}}}]);