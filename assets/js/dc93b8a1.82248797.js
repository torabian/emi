"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[656],{7213:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>b,frontMatter:()=>o,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"js/emi-fields-auto-init","title":"Emi Objects Auto-Init Feature","description":"In the DTO world, it often happens that an API promises to return a string, object, or array for a specific property. TypeScript can enforce this at the type level, but the main issue with most codegen tools is that they trust the definitions too much.","source":"@site/docs/js/emi-fields-auto-init.mdx","sourceDirName":"js","slug":"/js/emi-fields-auto-init","permalink":"/emi/docs/js/emi-fields-auto-init","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-fields-auto-init.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Javascript(Type?) Compiler","permalink":"/emi/docs/js/js-intro"},"next":{"title":"Emi Headers class generator","permalink":"/emi/docs/js/emi-headers-class"}}');var i=e(4848),a=e(8453);const o={sidebar_position:3},c="Emi Objects Auto-Init Feature",l={},r=[{value:"How Emi-Generated DTOs Solve This Problem",id:"how-emi-generated-dtos-solve-this-problem",level:2}];function p(t){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"emi-objects-auto-init-feature",children:"Emi Objects Auto-Init Feature"})}),"\n",(0,i.jsx)(n.p,{children:"In the DTO world, it often happens that an API promises to return a string, object, or array for a specific property. TypeScript can enforce this at the type level, but the main issue with most codegen tools is that they trust the definitions too much."}),"\n",(0,i.jsx)(n.p,{children:"Over time, APIs change, and the expected data type may not match what actually comes back. In strongly typed languages, this problem is usually handled automatically. For example, in Go, structs and primitives are always initialized, regardless of the input. Some languages don\u2019t even allow uninitialized values."}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript tries to address this, but only at compile time\u2014it doesn\u2019t validate data at runtime. That means code like ",(0,i.jsx)(n.code,{children:"const data = body.response.substring()"})," will break if the response is suddenly a number instead of a string."]}),"\n",(0,i.jsxs)(n.p,{children:["And these issues ",(0,i.jsx)(n.em,{children:"do"})," happen. Maybe not on day one, but eventually, as the codebase grows and multiple people contribute, inconsistencies creep in."]}),"\n",(0,i.jsx)(n.h2,{id:"how-emi-generated-dtos-solve-this-problem",children:"How Emi-Generated DTOs Solve This Problem"}),"\n",(0,i.jsx)(n.p,{children:"When you define an object in Emi, it generates both a TypeScript type and a class. When an action returns an instance of that class, all non-nullable fields are automatically initialized\u2014even if they are arrays, objects, or nested DTOs."}),"\n",(0,i.jsxs)(n.p,{children:["This ensures your code is always reliable. You don\u2019t need to sprinkle ",(0,i.jsx)(n.code,{children:"?"}),", ",(0,i.jsx)(n.code,{children:"??"}),", or ",(0,i.jsx)(n.code,{children:"typeof x === 'string'"})," checks everywhere."]}),"\n",(0,i.jsx)(n.p,{children:"For example, when generating an Emi class with nested objects, Emi will automatically initialize everything in the response, so you can safely work with the data without extra guards."}),"\n",(0,i.jsx)(n.p,{children:"Now, this is much more reliable code instead of just typing them, you almost never get undefined. But still, writing that manually\nis a hassle, and type checking and other tools might be lost. Now, let's take a look how this could be generated using Emi js compiler:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"name: AutoInitClass\nfields:\n  - name: object1\n    type: object\n    description: This field will be always initialised\n    fields:\n      - name: object2\n        type: object\n        description: This field also will be initialised, always.\n        fields:\n          - name: contacts\n            type: array\n            description: This field will be always an array\n            fields:\n              - name: email\n                type: string\n                default: emi-compiler@emi-compiler.com\n              - name: phone\n                type: string?\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"And Emi compiler would generate such shopisticated details (content is a bit long but worth to take a look at it.)\nEmi compiler generates ts type and, class, with full getter, setters and validators for each field."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for autoInitClassDto\n **/\nexport class AutoInitClassDto {\n  /**\n   * This field will be always initialised\n   * @type {AutoInitClassDto.Object1}\n   **/\n  #object1!: InstanceType<typeof AutoInitClassDto.Object1>;\n  /**\n   * This field will be always initialised\n   * @returns {AutoInitClassDto.Object1}\n   **/\n  get object1() {\n    return this.#object1;\n  }\n  /**\n   * This field will be always initialised\n   * @type {AutoInitClassDto.Object1}\n   **/\n  set object1(value: InstanceType<typeof AutoInitClassDto.Object1>) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof AutoInitClassDto.Object1) {\n      this.#object1 = value;\n    } else {\n      this.#object1 = new AutoInitClassDto.Object1(value);\n    }\n  }\n  setObject1(value: InstanceType<typeof AutoInitClassDto.Object1>) {\n    this.object1 = value;\n    return this;\n  }\n  /**\n   * The base class definition for object1\n   **/\n  static Object1 = class Object1 {\n    /**\n     * This field also will be initialised, always.\n     * @type {AutoInitClassDto.Object1.Object2}\n     **/\n    #object2!: InstanceType<typeof AutoInitClassDto.Object1.Object2>;\n    /**\n     * This field also will be initialised, always.\n     * @returns {AutoInitClassDto.Object1.Object2}\n     **/\n    get object2() {\n      return this.#object2;\n    }\n    /**\n     * This field also will be initialised, always.\n     * @type {AutoInitClassDto.Object1.Object2}\n     **/\n    set object2(value: InstanceType<typeof AutoInitClassDto.Object1.Object2>) {\n      // For objects, the sub type needs to always be instance of the sub class.\n      if (value instanceof AutoInitClassDto.Object1.Object2) {\n        this.#object2 = value;\n      } else {\n        this.#object2 = new AutoInitClassDto.Object1.Object2(value);\n      }\n    }\n    setObject2(value: InstanceType<typeof AutoInitClassDto.Object1.Object2>) {\n      this.object2 = value;\n      return this;\n    }\n    /**\n     * The base class definition for object2\n     **/\n    static Object2 = class Object2 {\n      /**\n       * This field will be always an array\n       * @type {AutoInitClassDto.Object1.Object2.Contacts}\n       **/\n      #contacts: InstanceType<\n        typeof AutoInitClassDto.Object1.Object2.Contacts\n      >[] = [];\n      /**\n       * This field will be always an array\n       * @returns {AutoInitClassDto.Object1.Object2.Contacts}\n       **/\n      get contacts() {\n        return this.#contacts;\n      }\n      /**\n       * This field will be always an array\n       * @type {AutoInitClassDto.Object1.Object2.Contacts}\n       **/\n      set contacts(\n        value: InstanceType<typeof AutoInitClassDto.Object1.Object2.Contacts>[],\n      ) {\n        // For arrays, you only can pass arrays to the object\n        if (!Array.isArray(value)) {\n          return;\n        }\n        if (\n          value.length > 0 &&\n          value[0] instanceof AutoInitClassDto.Object1.Object2.Contacts\n        ) {\n          this.#contacts = value;\n        } else {\n          this.#contacts = value.map(\n            (item) => new AutoInitClassDto.Object1.Object2.Contacts(item),\n          );\n        }\n      }\n      setContacts(\n        value: InstanceType<typeof AutoInitClassDto.Object1.Object2.Contacts>[],\n      ) {\n        this.contacts = value;\n        return this;\n      }\n      /**\n       * The base class definition for contacts\n       **/\n      static Contacts = class Contacts {\n        /**\n         *\n         * @type {string}\n         **/\n        #email: string = "emi-compiler@emi-compiler.com";\n        /**\n         *\n         * @returns {string}\n         **/\n        get email() {\n          return this.#email;\n        }\n        /**\n         *\n         * @type {string}\n         **/\n        set email(value: string) {\n          const correctType = typeof value === "string";\n          this.#email = correctType ? value : "" + value;\n        }\n        setEmail(value: string) {\n          this.email = value;\n          return this;\n        }\n        /**\n         *\n         * @type {string}\n         **/\n        #phone?: string | null = undefined;\n        /**\n         *\n         * @returns {string}\n         **/\n        get phone() {\n          return this.#phone;\n        }\n        /**\n         *\n         * @type {string}\n         **/\n        set phone(value: string | null | undefined) {\n          const correctType =\n            typeof value === "string" || value === undefined || value === null;\n          this.#phone = correctType ? value : "" + value;\n        }\n        setPhone(value: string | null | undefined) {\n          this.phone = value;\n          return this;\n        }\n        constructor(data: unknown = undefined) {\n          if (data === null || data === undefined) {\n            return;\n          }\n          if (typeof data === "string") {\n            this.applyFromObject(JSON.parse(data));\n          } else if (this.#isJsonAppliable(data)) {\n            this.applyFromObject(data);\n          } else {\n            throw new Error(\n              "Instance cannot be created on an unknown value, check the content being passed. got: " +\n                typeof data,\n            );\n          }\n        }\n        #isJsonAppliable(obj: unknown) {\n          const g = globalThis as any;\n          const isBuffer =\n            typeof g.Buffer !== "undefined" &&\n            typeof g.Buffer.isBuffer === "function" &&\n            g.Buffer.isBuffer(obj);\n          const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n          return (\n            obj &&\n            typeof obj === "object" &&\n            !Array.isArray(obj) &&\n            !isBuffer &&\n            !(obj instanceof ArrayBuffer) &&\n            !isBlob\n          );\n        }\n        /**\n         * casts the fields of a javascript object into the class properties one by one\n         **/\n        applyFromObject(data = {}) {\n          const d = data as Partial<Contacts>;\n          if (d.email !== undefined) {\n            this.email = d.email;\n          }\n          if (d.phone !== undefined) {\n            this.phone = d.phone;\n          }\n        }\n        /**\n         *\tSpecial toJSON override, since the field are private,\n         *\tJson stringify won\'t see them unless we mention it explicitly.\n         **/\n        toJSON() {\n          return {\n            email: this.#email,\n            phone: this.#phone,\n          };\n        }\n        toString() {\n          return JSON.stringify(this);\n        }\n        static get Fields() {\n          return {\n            email: "email",\n            phone: "phone",\n          };\n        }\n        /**\n         * Creates an instance of AutoInitClassDto.Object1.Object2.Contacts, and possibleDtoObject\n         * needs to satisfy the type requirement fully, otherwise typescript compile would\n         * be complaining.\n         **/\n        static from(\n          possibleDtoObject: AutoInitClassDtoType.Object1Type.Object2Type.ContactsType,\n        ) {\n          return new AutoInitClassDto.Object1.Object2.Contacts(\n            possibleDtoObject,\n          );\n        }\n        /**\n         * Creates an instance of AutoInitClassDto.Object1.Object2.Contacts, and partialDtoObject\n         * needs to satisfy the type, but partially, and rest of the content would\n         * be constructed according to data types and nullability.\n         **/\n        static with(\n          partialDtoObject: Partial<AutoInitClassDtoType.Object1Type.Object2Type.ContactsType>,\n        ) {\n          return new AutoInitClassDto.Object1.Object2.Contacts(\n            partialDtoObject,\n          );\n        }\n        copyWith(\n          partial: Partial<AutoInitClassDtoType.Object1Type.Object2Type.ContactsType>,\n        ): InstanceType<typeof AutoInitClassDto.Object1.Object2.Contacts> {\n          return new AutoInitClassDto.Object1.Object2.Contacts({\n            ...this.toJSON(),\n            ...partial,\n          });\n        }\n        clone(): InstanceType<\n          typeof AutoInitClassDto.Object1.Object2.Contacts\n        > {\n          return new AutoInitClassDto.Object1.Object2.Contacts(this.toJSON());\n        }\n      };\n      constructor(data: unknown = undefined) {\n        if (data === null || data === undefined) {\n          return;\n        }\n        if (typeof data === "string") {\n          this.applyFromObject(JSON.parse(data));\n        } else if (this.#isJsonAppliable(data)) {\n          this.applyFromObject(data);\n        } else {\n          throw new Error(\n            "Instance cannot be created on an unknown value, check the content being passed. got: " +\n              typeof data,\n          );\n        }\n      }\n      #isJsonAppliable(obj: unknown) {\n        const g = globalThis as any;\n        const isBuffer =\n          typeof g.Buffer !== "undefined" &&\n          typeof g.Buffer.isBuffer === "function" &&\n          g.Buffer.isBuffer(obj);\n        const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n        return (\n          obj &&\n          typeof obj === "object" &&\n          !Array.isArray(obj) &&\n          !isBuffer &&\n          !(obj instanceof ArrayBuffer) &&\n          !isBlob\n        );\n      }\n      /**\n       * casts the fields of a javascript object into the class properties one by one\n       **/\n      applyFromObject(data = {}) {\n        const d = data as Partial<Object2>;\n        if (d.contacts !== undefined) {\n          this.contacts = d.contacts;\n        }\n      }\n      /**\n       *\tSpecial toJSON override, since the field are private,\n       *\tJson stringify won\'t see them unless we mention it explicitly.\n       **/\n      toJSON() {\n        return {\n          contacts: this.#contacts,\n        };\n      }\n      toString() {\n        return JSON.stringify(this);\n      }\n      static get Fields() {\n        return {\n          contacts$: "contacts",\n          get contacts() {\n            return withPrefix(\n              "object1.object2.contacts[:i]",\n              AutoInitClassDto.Object1.Object2.Contacts.Fields,\n            );\n          },\n        };\n      }\n      /**\n       * Creates an instance of AutoInitClassDto.Object1.Object2, and possibleDtoObject\n       * needs to satisfy the type requirement fully, otherwise typescript compile would\n       * be complaining.\n       **/\n      static from(\n        possibleDtoObject: AutoInitClassDtoType.Object1Type.Object2Type,\n      ) {\n        return new AutoInitClassDto.Object1.Object2(possibleDtoObject);\n      }\n      /**\n       * Creates an instance of AutoInitClassDto.Object1.Object2, and partialDtoObject\n       * needs to satisfy the type, but partially, and rest of the content would\n       * be constructed according to data types and nullability.\n       **/\n      static with(\n        partialDtoObject: Partial<AutoInitClassDtoType.Object1Type.Object2Type>,\n      ) {\n        return new AutoInitClassDto.Object1.Object2(partialDtoObject);\n      }\n      copyWith(\n        partial: Partial<AutoInitClassDtoType.Object1Type.Object2Type>,\n      ): InstanceType<typeof AutoInitClassDto.Object1.Object2> {\n        return new AutoInitClassDto.Object1.Object2({\n          ...this.toJSON(),\n          ...partial,\n        });\n      }\n      clone(): InstanceType<typeof AutoInitClassDto.Object1.Object2> {\n        return new AutoInitClassDto.Object1.Object2(this.toJSON());\n      }\n    };\n    constructor(data: unknown = undefined) {\n      if (data === null || data === undefined) {\n        this.#lateInitFields();\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj: unknown) {\n      const g = globalThis as any;\n      const isBuffer =\n        typeof g.Buffer !== "undefined" &&\n        typeof g.Buffer.isBuffer === "function" &&\n        g.Buffer.isBuffer(obj);\n      const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Object1>;\n      if (d.object2 !== undefined) {\n        this.object2 = d.object2;\n      }\n      this.#lateInitFields(data);\n    }\n    /**\n     * These are the class instances, which need to be initialised, regardless of the constructor incoming data\n     **/\n    #lateInitFields(data = {}) {\n      const d = data as Partial<Object1>;\n      if (!(d.object2 instanceof AutoInitClassDto.Object1.Object2)) {\n        this.object2 = new AutoInitClassDto.Object1.Object2(d.object2 || {});\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        object2: this.#object2,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        object2$: "object2",\n        get object2() {\n          return withPrefix(\n            "object1.object2",\n            AutoInitClassDto.Object1.Object2.Fields,\n          );\n        },\n      };\n    }\n    /**\n     * Creates an instance of AutoInitClassDto.Object1, and possibleDtoObject\n     * needs to satisfy the type requirement fully, otherwise typescript compile would\n     * be complaining.\n     **/\n    static from(possibleDtoObject: AutoInitClassDtoType.Object1Type) {\n      return new AutoInitClassDto.Object1(possibleDtoObject);\n    }\n    /**\n     * Creates an instance of AutoInitClassDto.Object1, and partialDtoObject\n     * needs to satisfy the type, but partially, and rest of the content would\n     * be constructed according to data types and nullability.\n     **/\n    static with(partialDtoObject: Partial<AutoInitClassDtoType.Object1Type>) {\n      return new AutoInitClassDto.Object1(partialDtoObject);\n    }\n    copyWith(\n      partial: Partial<AutoInitClassDtoType.Object1Type>,\n    ): InstanceType<typeof AutoInitClassDto.Object1> {\n      return new AutoInitClassDto.Object1({ ...this.toJSON(), ...partial });\n    }\n    clone(): InstanceType<typeof AutoInitClassDto.Object1> {\n      return new AutoInitClassDto.Object1(this.toJSON());\n    }\n  };\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      this.#lateInitFields();\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<AutoInitClassDto>;\n    if (d.object1 !== undefined) {\n      this.object1 = d.object1;\n    }\n    this.#lateInitFields(data);\n  }\n  /**\n   * These are the class instances, which need to be initialised, regardless of the constructor incoming data\n   **/\n  #lateInitFields(data = {}) {\n    const d = data as Partial<AutoInitClassDto>;\n    if (!(d.object1 instanceof AutoInitClassDto.Object1)) {\n      this.object1 = new AutoInitClassDto.Object1(d.object1 || {});\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      object1: this.#object1,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      object1$: "object1",\n      get object1() {\n        return withPrefix("object1", AutoInitClassDto.Object1.Fields);\n      },\n    };\n  }\n  /**\n   * Creates an instance of AutoInitClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: AutoInitClassDtoType) {\n    return new AutoInitClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of AutoInitClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: Partial<AutoInitClassDtoType>) {\n    return new AutoInitClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: Partial<AutoInitClassDtoType>,\n  ): InstanceType<typeof AutoInitClassDto> {\n    return new AutoInitClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof AutoInitClassDto> {\n    return new AutoInitClassDto(this.toJSON());\n  }\n}\nexport abstract class AutoInitClassDtoFactory {\n  abstract create(data: unknown): AutoInitClassDto;\n}\n/**\n * The base type definition for autoInitClassDto\n **/\nexport type AutoInitClassDtoType = {\n  /**\n   * This field will be always initialised\n   * @type {AutoInitClassDtoType.Object1Type}\n   **/\n  object1: AutoInitClassDtoType.Object1Type;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace AutoInitClassDtoType {\n  /**\n   * The base type definition for object1Type\n   **/\n  export type Object1Type = {\n    /**\n     * This field also will be initialised, always.\n     * @type {AutoInitClassDtoType.Object1Type.Object2Type}\n     **/\n    object2: AutoInitClassDtoType.Object1Type.Object2Type;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace Object1Type {\n    /**\n     * The base type definition for object2Type\n     **/\n    export type Object2Type = {\n      /**\n       * This field will be always an array\n       * @type {AutoInitClassDtoType.Object1Type.Object2Type.ContactsType[]}\n       **/\n      contacts: AutoInitClassDtoType.Object1Type.Object2Type.ContactsType[];\n    };\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    export namespace Object2Type {\n      /**\n       * The base type definition for contactsType\n       **/\n      export type ContactsType = {\n        /**\n         *\n         * @type {string}\n         **/\n        email: string;\n        /**\n         *\n         * @type {string}\n         **/\n        phone?: string;\n      };\n      // eslint-disable-next-line @typescript-eslint/no-namespace\n      export namespace ContactsType {}\n    }\n  }\n}\n\n'})})]})}function b(t={}){const{wrapper:n}={...(0,a.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(p,{...t})}):p(t)}},8453:(t,n,e)=>{e.d(n,{R:()=>o,x:()=>c});var s=e(6540);const i={},a=s.createContext(i);function o(t){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof t?t(n):{...n,...t}},[n,t])}function c(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:o(t.components),s.createElement(a.Provider,{value:n},t.children)}}}]);