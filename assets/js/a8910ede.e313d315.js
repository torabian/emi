"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[562],{7788:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"js/emi-static-fields","title":"Static fields path generation","description":"In Javascript world, often you need to set a variable using a json path, for example using \'lodash\' or \'formik\' libraries. This is very common way to set value of a variable, deep inside an object, array, or combination.","source":"@site/docs/js/emi-static-fields.mdx","sourceDirName":"js","slug":"/js/emi-static-fields","permalink":"/emi/docs/js/emi-static-fields","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-static-fields.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"WebSocket generation in Emi","permalink":"/emi/docs/js/emi-javascript-web-socket"},"next":{"title":"Emi string data type","permalink":"/emi/docs/js/emi-string-data-type"}}');var s=t(4848),o=t(8453);const a={sidebar_position:4},r="Static fields path generation",l={},d=[{value:"Issue with the code",id:"issue-with-the-code",level:2},{value:"How Emi static generation would solve this?",id:"how-emi-static-generation-would-solve-this",level:2}];function c(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"static-fields-path-generation",children:"Static fields path generation"})}),"\n",(0,s.jsx)(e.p,{children:"In Javascript world, often you need to set a variable using a json path, for example using 'lodash' or 'formik' libraries. This is very common way to set value of a variable, deep inside an object, array, or combination."}),"\n",(0,s.jsx)(e.p,{children:"Let's assume the following code:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const form = {\n  firstName: 'Ali',\n  loginHistory: [\n    {\n      time: new Date(),\n      data: {\n        ipAddress: '0.0.0.0',\n      } \n    }\n  ]\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Now, let's call the ",(0,s.jsx)(e.code,{children:"lodash.set(field, value)"})," function on the following code:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import { set } from 'lodash';\n\nset(form, 'loginHistory[0].data.ipAddress', '192.168.1.1')\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"A side note is you might ask why not set 'form.loginHistory[0].data.ipAddress = \"192.168.1.1' instead,\nin javascript world it's very common to use the path selector, in forms context, or when you do not have access\nto whole flow."})}),"\n",(0,s.jsx)(e.h2,{id:"issue-with-the-code",children:"Issue with the code"}),"\n",(0,s.jsxs)(e.p,{children:["As we called ",(0,s.jsx)(e.code,{children:"set"})," function with string path finder, this path might be changed over time, and\njavascript compiler might silently continue to set that form, and it's hard to debug.\nIf the ",(0,s.jsx)(e.code,{children:"form.loginHistory"})," becomes ",(0,s.jsx)(e.code,{children:"form.loginHistories"}),", then still some part of code still\ntries to set the address in a wrong location."]}),"\n",(0,s.jsx)(e.h2,{id:"how-emi-static-generation-would-solve-this",children:"How Emi static generation would solve this?"}),"\n",(0,s.jsxs)(e.p,{children:["When defining a model with Emi, compiler generates a ",(0,s.jsx)(e.code,{children:"static Fields = ... "})," statement in each sub class,\nand automatically connect the path in depth. Let's assume the following schema, this time written in Emi."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"- name: firstName\n  type: string\n- name: loginHistory\n  type: array\n  fields:\n    - name: time\n      type: string\n    - name: data\n      type: object\n      fields:\n        - name: ipAddress\n          type: string\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:["And as you can see in the generated code there are ",(0,s.jsx)(e.code,{children:"static get Fields()"})," statements, which instead\nof setting string, now you can:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import { set } from 'lodash';\n\nset(form, at(Anonymouse.Fields.loginHistory.data.ipAddress, 0), '192.168.1.1')\n"})}),"\n",(0,s.jsx)(e.p,{children:"Now in case the model changes, compiler would complain, and there is zero chance to modify no existing fields.\nFew notes to remember:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"When a field is object or array (and all similar types), the field itself appears twice, first with $ sign,\nwhich is representing the string field, and another time as the name of field, which would reference the other\nclass representing the sub class, or original reference in case of Dto or Entity."}),"\n",(0,s.jsxs)(e.li,{children:["In javascript core library, there is a ",(0,s.jsx)(e.code,{children:"at"})," function, which would help to resolve the array string paths. You can\npass number as many as you want, and it would replace [",":i","] statements to have proper index selected."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for anonymouse\n **/\nexport class Anonymouse {\n  /**\n   *\n   * @type {string}\n   **/\n  #firstName = "";\n  /**\n   *\n   * @returns {string}\n   **/\n  get firstName() {\n    return this.#firstName;\n  }\n  /**\n   *\n   * @type {string}\n   **/\n  set firstName(value) {\n    const correctType = typeof value === "string";\n    this.#firstName = correctType ? value : "" + value;\n  }\n  setFirstName(value) {\n    this.firstName = value;\n    return this;\n  }\n  /**\n   *\n   * @type {Anonymouse.LoginHistory}\n   **/\n  #loginHistory = [];\n  /**\n   *\n   * @returns {Anonymouse.LoginHistory}\n   **/\n  get loginHistory() {\n    return this.#loginHistory;\n  }\n  /**\n   *\n   * @type {Anonymouse.LoginHistory}\n   **/\n  set loginHistory(value) {\n    // For arrays, you only can pass arrays to the object\n    if (!Array.isArray(value)) {\n      return;\n    }\n    if (value.length > 0 && value[0] instanceof Anonymouse.LoginHistory) {\n      this.#loginHistory = value;\n    } else {\n      this.#loginHistory = value.map(\n        (item) => new Anonymouse.LoginHistory(item),\n      );\n    }\n  }\n  setLoginHistory(value) {\n    this.loginHistory = value;\n    return this;\n  }\n  /**\n   * The base class definition for loginHistory\n   **/\n  static LoginHistory = class LoginHistory {\n    /**\n     *\n     * @type {string}\n     **/\n    #time = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get time() {\n      return this.#time;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set time(value) {\n      const correctType = typeof value === "string";\n      this.#time = correctType ? value : "" + value;\n    }\n    setTime(value) {\n      this.time = value;\n      return this;\n    }\n    /**\n     *\n     * @type {Anonymouse.LoginHistory.Data}\n     **/\n    #data;\n    /**\n     *\n     * @returns {Anonymouse.LoginHistory.Data}\n     **/\n    get data() {\n      return this.#data;\n    }\n    /**\n     *\n     * @type {Anonymouse.LoginHistory.Data}\n     **/\n    set data(value) {\n      // For objects, the sub type needs to always be instance of the sub class.\n      if (value instanceof Anonymouse.LoginHistory.Data) {\n        this.#data = value;\n      } else {\n        this.#data = new Anonymouse.LoginHistory.Data(value);\n      }\n    }\n    setData(value) {\n      this.data = value;\n      return this;\n    }\n    /**\n     * The base class definition for data\n     **/\n    static Data = class Data {\n      /**\n       *\n       * @type {string}\n       **/\n      #ipAddress = "";\n      /**\n       *\n       * @returns {string}\n       **/\n      get ipAddress() {\n        return this.#ipAddress;\n      }\n      /**\n       *\n       * @type {string}\n       **/\n      set ipAddress(value) {\n        const correctType = typeof value === "string";\n        this.#ipAddress = correctType ? value : "" + value;\n      }\n      setIpAddress(value) {\n        this.ipAddress = value;\n        return this;\n      }\n      constructor(data) {\n        if (data === null || data === undefined) {\n          return;\n        }\n        if (typeof data === "string") {\n          this.applyFromObject(JSON.parse(data));\n        } else if (this.#isJsonAppliable(data)) {\n          this.applyFromObject(data);\n        } else {\n          throw new Error(\n            "Instance cannot be created on an unknown value, check the content being passed. got: " +\n              typeof data,\n          );\n        }\n      }\n      #isJsonAppliable(obj) {\n        const isBuffer =\n          typeof globalThis.Buffer !== "undefined" &&\n          typeof globalThis.Buffer.isBuffer === "function" &&\n          globalThis.Buffer.isBuffer(obj);\n        const isBlob =\n          typeof globalThis.Blob !== "undefined" &&\n          obj instanceof globalThis.Blob;\n        return (\n          obj &&\n          typeof obj === "object" &&\n          !Array.isArray(obj) &&\n          !isBuffer &&\n          !(obj instanceof ArrayBuffer) &&\n          !isBlob\n        );\n      }\n      /**\n       * casts the fields of a javascript object into the class properties one by one\n       **/\n      applyFromObject(data = {}) {\n        const d = data;\n        if (d.ipAddress !== undefined) {\n          this.ipAddress = d.ipAddress;\n        }\n      }\n      /**\n       *\tSpecial toJSON override, since the field are private,\n       *\tJson stringify won\'t see them unless we mention it explicitly.\n       **/\n      toJSON() {\n        return {\n          ipAddress: this.#ipAddress,\n        };\n      }\n      toString() {\n        return JSON.stringify(this);\n      }\n      static get Fields() {\n        return {\n          ipAddress: "ipAddress",\n        };\n      }\n    };\n    constructor(data) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj) {\n      const isBuffer =\n        typeof globalThis.Buffer !== "undefined" &&\n        typeof globalThis.Buffer.isBuffer === "function" &&\n        globalThis.Buffer.isBuffer(obj);\n      const isBlob =\n        typeof globalThis.Blob !== "undefined" &&\n        obj instanceof globalThis.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data;\n      if (d.time !== undefined) {\n        this.time = d.time;\n      }\n      if (d.data !== undefined) {\n        this.data = d.data;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        time: this.#time,\n        data: this.#data,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        time: "time",\n        data$: "data",\n        get data() {\n          return withPrefix(\n            "loginHistory.data",\n            Anonymouse.LoginHistory.Data.Fields,\n          );\n        },\n      };\n    }\n  };\n  constructor(data) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj) {\n    const isBuffer =\n      typeof globalThis.Buffer !== "undefined" &&\n      typeof globalThis.Buffer.isBuffer === "function" &&\n      globalThis.Buffer.isBuffer(obj);\n    const isBlob =\n      typeof globalThis.Blob !== "undefined" && obj instanceof globalThis.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data;\n    if (d.firstName !== undefined) {\n      this.firstName = d.firstName;\n    }\n    if (d.loginHistory !== undefined) {\n      this.loginHistory = d.loginHistory;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      firstName: this.#firstName,\n      loginHistory: this.#loginHistory,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      firstName: "firstName",\n      loginHistory$: "loginHistory",\n      get loginHistory() {\n        return withPrefix("loginHistory[:i]", Anonymouse.LoginHistory.Fields);\n      },\n    };\n  }\n}\n\n'})})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);