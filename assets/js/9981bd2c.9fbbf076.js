"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[347],{4839:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"js/emi-boolean-data-type","title":"Emi boolean data type","description":"Given the following example:","source":"@site/docs/js/emi-boolean-data-type.mdx","sourceDirName":"js","slug":"/js/emi-boolean-data-type","permalink":"/emi/docs/js/emi-boolean-data-type","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-boolean-data-type.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Emi string data type","permalink":"/emi/docs/js/emi-string-data-type"},"next":{"title":"Emi integer data type","permalink":"/emi/docs/js/emi-int-data-type"}}');var l=t(4848),a=t(8453);const i={sidebar_position:5},s="Emi boolean data type",r={},u=[];function d(n){const e={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.header,{children:(0,l.jsx)(e.h1,{id:"emi-boolean-data-type",children:"Emi boolean data type"})}),"\n",(0,l.jsx)(e.p,{children:"Given the following example:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-yaml",children:"name: MyBoolClass\nfields:\n  - name: boolWithDefault\n    default: true\n    type: bool\n  - name: plainBool\n    type: bool\n\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"bool"})," and ",(0,l.jsx)(e.code,{children:"bool?"})," map directly to JavaScript's ",(0,l.jsx)(e.code,{children:"boolean"})," type."]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"bool"})," fields are always required and default to ",(0,l.jsx)(e.code,{children:"false"})," unless another default is provided."]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"bool?"})," fields allow both ",(0,l.jsx)(e.code,{children:"null"})," and ",(0,l.jsx)(e.code,{children:"undefined"}),", with ",(0,l.jsx)(e.code,{children:"undefined"})," being the default if not specified."]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["Just like with strings, Emi generates a private backing field (",(0,l.jsx)(e.code,{children:"#field"}),") and a pair of getters and setters.\nThis ensures type safety and avoids accidental runtime errors."]}),"\n",(0,l.jsxs)(e.p,{children:["Example with a non-nullable ",(0,l.jsx)(e.code,{children:"bool"}),":"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-ts",children:'/**\n * The base class definition for myBoolClassDto\n **/\nexport class MyBoolClassDto {\n  /**\n   *\n   * @type {boolean}\n   **/\n  #boolWithDefault: boolean = true;\n  /**\n   *\n   * @returns {boolean}\n   **/\n  get boolWithDefault() {\n    return this.#boolWithDefault;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  set boolWithDefault(value: boolean) {\n    this.#boolWithDefault = Boolean(value);\n  }\n  setBoolWithDefault(value: boolean) {\n    this.boolWithDefault = value;\n    return this;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  #plainBool!: boolean;\n  /**\n   *\n   * @returns {boolean}\n   **/\n  get plainBool() {\n    return this.#plainBool;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  set plainBool(value: boolean) {\n    this.#plainBool = Boolean(value);\n  }\n  setPlainBool(value: boolean) {\n    this.plainBool = value;\n    return this;\n  }\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyBoolClassDto>;\n    if (d.boolWithDefault !== undefined) {\n      this.boolWithDefault = d.boolWithDefault;\n    }\n    if (d.plainBool !== undefined) {\n      this.plainBool = d.plainBool;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      boolWithDefault: this.#boolWithDefault,\n      plainBool: this.#plainBool,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      boolWithDefault: "boolWithDefault",\n      plainBool: "plainBool",\n    };\n  }\n  /**\n   * Creates an instance of MyBoolClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyBoolClassDtoType) {\n    return new MyBoolClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyBoolClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyBoolClassDtoType>) {\n    return new MyBoolClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyBoolClassDtoType>,\n  ): InstanceType<typeof MyBoolClassDto> {\n    return new MyBoolClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyBoolClassDto> {\n    return new MyBoolClassDto(this.toJSON());\n  }\n}\nexport abstract class MyBoolClassDtoFactory {\n  abstract create(data: unknown): MyBoolClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myBoolClassDto\n **/\nexport type MyBoolClassDtoType = {\n  /**\n   *\n   * @type {boolean}\n   **/\n  boolWithDefault: boolean;\n  /**\n   *\n   * @type {boolean}\n   **/\n  plainBool: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyBoolClassDtoType {}\n\n'})}),"\n",(0,l.jsx)(e.p,{children:"Given the following example:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-yaml",children:"name: MyBoolClass\nfields:\n  - name: nullableBoolWithDefault\n    default: true\n    type: bool?\n  - name: nullableBoolWithoutDefault\n    type: bool?\n\n"})}),"\n",(0,l.jsxs)(e.p,{children:["With ",(0,l.jsx)(e.code,{children:"bool?"}),", the backing field is initialised with ",(0,l.jsx)(e.code,{children:"undefined"}),".\nYou can explicitly set it to ",(0,l.jsx)(e.code,{children:"true"}),", ",(0,l.jsx)(e.code,{children:"false"}),", or ",(0,l.jsx)(e.code,{children:"null"}),".\nIf a default is provided, it will be respected."]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-ts",children:'/**\n * The base class definition for myBoolClassDto\n **/\nexport class MyBoolClassDto {\n  /**\n   *\n   * @type {boolean}\n   **/\n  #nullableBoolWithDefault?: boolean | null = true;\n  /**\n   *\n   * @returns {boolean}\n   **/\n  get nullableBoolWithDefault() {\n    return this.#nullableBoolWithDefault;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  set nullableBoolWithDefault(value: boolean | null | undefined) {\n    const correctType =\n      value === true ||\n      value === false ||\n      value === undefined ||\n      value === null;\n    this.#nullableBoolWithDefault = correctType ? value : Boolean(value);\n  }\n  setNullableBoolWithDefault(value: boolean | null | undefined) {\n    this.nullableBoolWithDefault = value;\n    return this;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  #nullableBoolWithoutDefault?: boolean | null = undefined;\n  /**\n   *\n   * @returns {boolean}\n   **/\n  get nullableBoolWithoutDefault() {\n    return this.#nullableBoolWithoutDefault;\n  }\n  /**\n   *\n   * @type {boolean}\n   **/\n  set nullableBoolWithoutDefault(value: boolean | null | undefined) {\n    const correctType =\n      value === true ||\n      value === false ||\n      value === undefined ||\n      value === null;\n    this.#nullableBoolWithoutDefault = correctType ? value : Boolean(value);\n  }\n  setNullableBoolWithoutDefault(value: boolean | null | undefined) {\n    this.nullableBoolWithoutDefault = value;\n    return this;\n  }\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyBoolClassDto>;\n    if (d.nullableBoolWithDefault !== undefined) {\n      this.nullableBoolWithDefault = d.nullableBoolWithDefault;\n    }\n    if (d.nullableBoolWithoutDefault !== undefined) {\n      this.nullableBoolWithoutDefault = d.nullableBoolWithoutDefault;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      nullableBoolWithDefault: this.#nullableBoolWithDefault,\n      nullableBoolWithoutDefault: this.#nullableBoolWithoutDefault,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      nullableBoolWithDefault: "nullableBoolWithDefault",\n      nullableBoolWithoutDefault: "nullableBoolWithoutDefault",\n    };\n  }\n  /**\n   * Creates an instance of MyBoolClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyBoolClassDtoType) {\n    return new MyBoolClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyBoolClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyBoolClassDtoType>) {\n    return new MyBoolClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyBoolClassDtoType>,\n  ): InstanceType<typeof MyBoolClassDto> {\n    return new MyBoolClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyBoolClassDto> {\n    return new MyBoolClassDto(this.toJSON());\n  }\n}\nexport abstract class MyBoolClassDtoFactory {\n  abstract create(data: unknown): MyBoolClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myBoolClassDto\n **/\nexport type MyBoolClassDtoType = {\n  /**\n   *\n   * @type {boolean}\n   **/\n  nullableBoolWithDefault?: boolean;\n  /**\n   *\n   * @type {boolean}\n   **/\n  nullableBoolWithoutDefault?: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyBoolClassDtoType {}\n\n'})})]})}function c(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>s});var o=t(6540);const l={},a=o.createContext(l);function i(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:i(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);