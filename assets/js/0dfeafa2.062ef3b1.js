"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[304],{2650:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"js/emi-array-data-type","title":"Emi array data type","description":"Example schema:","source":"@site/docs/js/emi-array-data-type.mdx","sourceDirName":"js","slug":"/js/emi-array-data-type","permalink":"/emi/docs/js/emi-array-data-type","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-array-data-type.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Emi object data type","permalink":"/emi/docs/js/emi-object-data-type"},"next":{"title":"Complex Types in Emi","permalink":"/emi/docs/js/emi-complex-types"}}');var s=t(4848),r=t(8453);const i={sidebar_position:9},o="Emi array data type",l={},c=[];function y(n){const e={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"emi-array-data-type",children:"Emi array data type"})}),"\n",(0,s.jsx)(e.p,{children:"Example schema:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"name: MyArrayClass\nfields:\n  - name: contacts\n    type: array\n    fields:\n      - name: email\n        type: string\n      - name: phone\n        type: string?\n\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"array"})," represents a list of items."]}),"\n",(0,s.jsxs)(e.li,{children:["You must define an ",(0,s.jsx)(e.code,{children:"items"})," field with the child type."]}),"\n",(0,s.jsxs)(e.li,{children:["Defaults to an empty array ",(0,s.jsx)(e.code,{children:"[]"})," if not specified."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"array?"})," allows ",(0,s.jsx)(e.code,{children:"null"}),"/ ",(0,s.jsx)(e.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for myArrayClassDto\n **/\nexport class MyArrayClassDto {\n  /**\n   *\n   * @type {MyArrayClassDto.Contacts}\n   **/\n  #contacts: InstanceType<typeof MyArrayClassDto.Contacts>[] = [];\n  /**\n   *\n   * @returns {MyArrayClassDto.Contacts}\n   **/\n  get contacts() {\n    return this.#contacts;\n  }\n  /**\n   *\n   * @type {MyArrayClassDto.Contacts}\n   **/\n  set contacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {\n    // For arrays, you only can pass arrays to the object\n    if (!Array.isArray(value)) {\n      return;\n    }\n    if (value.length > 0 && value[0] instanceof MyArrayClassDto.Contacts) {\n      this.#contacts = value;\n    } else {\n      this.#contacts = value.map((item) => new MyArrayClassDto.Contacts(item));\n    }\n  }\n  setContacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {\n    this.contacts = value;\n    return this;\n  }\n  /**\n   * The base class definition for contacts\n   **/\n  static Contacts = class Contacts {\n    /**\n     *\n     * @type {string}\n     **/\n    #email: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get email() {\n      return this.#email;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set email(value: string) {\n      const correctType = typeof value === "string";\n      this.#email = correctType ? value : "" + value;\n    }\n    setEmail(value: string) {\n      this.email = value;\n      return this;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    #phone?: string | null = undefined;\n    /**\n     *\n     * @returns {string}\n     **/\n    get phone() {\n      return this.#phone;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set phone(value: string | null | undefined) {\n      const correctType =\n        typeof value === "string" || value === undefined || value === null;\n      this.#phone = correctType ? value : "" + value;\n    }\n    setPhone(value: string | null | undefined) {\n      this.phone = value;\n      return this;\n    }\n    constructor(data) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj) {\n      const isBuffer =\n        typeof globalThis.Buffer !== "undefined" &&\n        typeof globalThis.Buffer.isBuffer === "function" &&\n        globalThis.Buffer.isBuffer(obj);\n      const isBlob =\n        typeof globalThis.Blob !== "undefined" &&\n        obj instanceof globalThis.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Contacts>;\n      if (d.email !== undefined) {\n        this.email = d.email;\n      }\n      if (d.phone !== undefined) {\n        this.phone = d.phone;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        email: this.#email,\n        phone: this.#phone,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        email: "email",\n        phone: "phone",\n      };\n    }\n  };\n  constructor(data) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj) {\n    const isBuffer =\n      typeof globalThis.Buffer !== "undefined" &&\n      typeof globalThis.Buffer.isBuffer === "function" &&\n      globalThis.Buffer.isBuffer(obj);\n    const isBlob =\n      typeof globalThis.Blob !== "undefined" && obj instanceof globalThis.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyArrayClassDto>;\n    if (d.contacts !== undefined) {\n      this.contacts = d.contacts;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      contacts: this.#contacts,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      contacts$: "contacts",\n      get contacts() {\n        return withPrefix("contacts[:i]", MyArrayClassDto.Contacts.Fields);\n      },\n    };\n  }\n}\nexport abstract class MyArrayClassDtoFactory {\n  abstract create(data: unknown): MyArrayClassDto;\n}\n/**\n * The base type definition for myArrayClassDto\n **/\nexport type MyArrayClassDtoType = {\n  /**\n   *\n   * @type {MyArrayClassDtoType.ContactsType[]}\n   **/\n  contacts: MyArrayClassDtoType.ContactsType[];\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyArrayClassDtoType {\n  /**\n   * The base type definition for contactsType\n   **/\n  export type ContactsType = {\n    /**\n     *\n     * @type {string}\n     **/\n    email: string;\n    /**\n     *\n     * @type {string}\n     **/\n    phone?: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace ContactsType {}\n}\n\n'})}),"\n",(0,s.jsx)(e.p,{children:"Array of objects:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"name: MyArrayClass\nfields:\n  - name: contacts\n    type: array\n    fields:\n      - name: email\n        type: string\n      - name: phone\n        type: string?\n\n"})}),"\n",(0,s.jsx)(e.p,{children:"Arrays can hold primitive types or nested objects."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for myArrayClassDto\n **/\nexport class MyArrayClassDto {\n  /**\n   *\n   * @type {MyArrayClassDto.Contacts}\n   **/\n  #contacts: InstanceType<typeof MyArrayClassDto.Contacts>[] = [];\n  /**\n   *\n   * @returns {MyArrayClassDto.Contacts}\n   **/\n  get contacts() {\n    return this.#contacts;\n  }\n  /**\n   *\n   * @type {MyArrayClassDto.Contacts}\n   **/\n  set contacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {\n    // For arrays, you only can pass arrays to the object\n    if (!Array.isArray(value)) {\n      return;\n    }\n    if (value.length > 0 && value[0] instanceof MyArrayClassDto.Contacts) {\n      this.#contacts = value;\n    } else {\n      this.#contacts = value.map((item) => new MyArrayClassDto.Contacts(item));\n    }\n  }\n  setContacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {\n    this.contacts = value;\n    return this;\n  }\n  /**\n   * The base class definition for contacts\n   **/\n  static Contacts = class Contacts {\n    /**\n     *\n     * @type {string}\n     **/\n    #email: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get email() {\n      return this.#email;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set email(value: string) {\n      const correctType = typeof value === "string";\n      this.#email = correctType ? value : "" + value;\n    }\n    setEmail(value: string) {\n      this.email = value;\n      return this;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    #phone?: string | null = undefined;\n    /**\n     *\n     * @returns {string}\n     **/\n    get phone() {\n      return this.#phone;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set phone(value: string | null | undefined) {\n      const correctType =\n        typeof value === "string" || value === undefined || value === null;\n      this.#phone = correctType ? value : "" + value;\n    }\n    setPhone(value: string | null | undefined) {\n      this.phone = value;\n      return this;\n    }\n    constructor(data) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj) {\n      const isBuffer =\n        typeof globalThis.Buffer !== "undefined" &&\n        typeof globalThis.Buffer.isBuffer === "function" &&\n        globalThis.Buffer.isBuffer(obj);\n      const isBlob =\n        typeof globalThis.Blob !== "undefined" &&\n        obj instanceof globalThis.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Contacts>;\n      if (d.email !== undefined) {\n        this.email = d.email;\n      }\n      if (d.phone !== undefined) {\n        this.phone = d.phone;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        email: this.#email,\n        phone: this.#phone,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        email: "email",\n        phone: "phone",\n      };\n    }\n  };\n  constructor(data) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj) {\n    const isBuffer =\n      typeof globalThis.Buffer !== "undefined" &&\n      typeof globalThis.Buffer.isBuffer === "function" &&\n      globalThis.Buffer.isBuffer(obj);\n    const isBlob =\n      typeof globalThis.Blob !== "undefined" && obj instanceof globalThis.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyArrayClassDto>;\n    if (d.contacts !== undefined) {\n      this.contacts = d.contacts;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      contacts: this.#contacts,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      contacts$: "contacts",\n      get contacts() {\n        return withPrefix("contacts[:i]", MyArrayClassDto.Contacts.Fields);\n      },\n    };\n  }\n}\nexport abstract class MyArrayClassDtoFactory {\n  abstract create(data: unknown): MyArrayClassDto;\n}\n/**\n * The base type definition for myArrayClassDto\n **/\nexport type MyArrayClassDtoType = {\n  /**\n   *\n   * @type {MyArrayClassDtoType.ContactsType[]}\n   **/\n  contacts: MyArrayClassDtoType.ContactsType[];\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyArrayClassDtoType {\n  /**\n   * The base type definition for contactsType\n   **/\n  export type ContactsType = {\n    /**\n     *\n     * @type {string}\n     **/\n    email: string;\n    /**\n     *\n     * @type {string}\n     **/\n    phone?: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace ContactsType {}\n}\n\n'})}),"\n",(0,s.jsx)(e.p,{children:"Nullable version:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"name: MyArrayClass\nfields:\n  - name: nullableTags\n    type: array?\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Defaults to ",(0,s.jsx)(e.code,{children:"undefined"}),", but you can assign an array or ",(0,s.jsx)(e.code,{children:"null"}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for myArrayClassDto\n **/\nexport class MyArrayClassDto {\n  /**\n   *\n   * @type {MyArrayClassDto.NullableTags}\n   **/\n  #nullableTags?:\n    | InstanceType<typeof MyArrayClassDto.NullableTags>[]\n    | null\n    | undefined\n    | null = undefined;\n  /**\n   *\n   * @returns {MyArrayClassDto.NullableTags}\n   **/\n  get nullableTags() {\n    return this.#nullableTags;\n  }\n  /**\n   *\n   * @type {MyArrayClassDto.NullableTags}\n   **/\n  set nullableTags(\n    value:\n      | InstanceType<typeof MyArrayClassDto.NullableTags>[]\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    // For arrays, you only can pass arrays to the object\n    if (!Array.isArray(value)) {\n      return;\n    }\n    if (value.length > 0 && value[0] instanceof MyArrayClassDto.NullableTags) {\n      this.#nullableTags = value;\n    } else {\n      this.#nullableTags = value.map(\n        (item) => new MyArrayClassDto.NullableTags(item),\n      );\n    }\n  }\n  setNullableTags(\n    value:\n      | InstanceType<typeof MyArrayClassDto.NullableTags>[]\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    this.nullableTags = value;\n    return this;\n  }\n  constructor(data) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj) {\n    const isBuffer =\n      typeof globalThis.Buffer !== "undefined" &&\n      typeof globalThis.Buffer.isBuffer === "function" &&\n      globalThis.Buffer.isBuffer(obj);\n    const isBlob =\n      typeof globalThis.Blob !== "undefined" && obj instanceof globalThis.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyArrayClassDto>;\n    if (d.nullableTags !== undefined) {\n      this.nullableTags = d.nullableTags;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      nullableTags: this.#nullableTags,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      nullableTags$: "nullableTags",\n      get nullableTags() {\n        return withPrefix(\n          "nullableTags[:i]",\n          MyArrayClassDto.NullableTags.Fields,\n        );\n      },\n    };\n  }\n}\nexport abstract class MyArrayClassDtoFactory {\n  abstract create(data: unknown): MyArrayClassDto;\n}\n/**\n * The base type definition for myArrayClassDto\n **/\nexport type MyArrayClassDtoType = {\n  /**\n   *\n   * @type {any[]}\n   **/\n  nullableTags?: any[];\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyArrayClassDtoType {}\n\n'})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(y,{...n})}):y(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var a=t(6540);const s={},r=a.createContext(s);function i(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);