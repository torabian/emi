"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[307],{1061:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"js/emi-object-data-type","title":"Emi object data type","description":"Example schema:","source":"@site/docs/js/emi-object-data-type.mdx","sourceDirName":"js","slug":"/js/emi-object-data-type","permalink":"/emi/docs/js/emi-object-data-type","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-object-data-type.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Emi float64 data type","permalink":"/emi/docs/js/emi-float64-data-type"},"next":{"title":"Emi array data type","permalink":"/emi/docs/js/emi-array-data-type"}}');var a=t(4848),i=t(8453);const o={sidebar_position:8},r="Emi object data type",l={},c=[];function p(n){const e={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"emi-object-data-type",children:"Emi object data type"})}),"\n",(0,a.jsx)(e.p,{children:"Example schema:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:"name: MyObjectClass\nfields:\n  - name: profile\n    type: object\n    fields:\n      - name: firstName\n        type: string\n      - name: age\n        type: int\n\n"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"object"})," lets you embed nested fields inside your class."]}),"\n",(0,a.jsx)(e.li,{children:"Works like inline type definition in TypeScript."}),"\n",(0,a.jsxs)(e.li,{children:["Defaults to an empty object ",(0,a.jsx)(e.code,{children:"{}"})," if not specified."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"object?"})," allows ",(0,a.jsx)(e.code,{children:"null"}),"/ ",(0,a.jsx)(e.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for myObjectClassDto\n **/\nexport class MyObjectClassDto {\n  /**\n   *\n   * @type {MyObjectClassDto.Profile}\n   **/\n  #profile!: InstanceType<typeof MyObjectClassDto.Profile>;\n  /**\n   *\n   * @returns {MyObjectClassDto.Profile}\n   **/\n  get profile() {\n    return this.#profile;\n  }\n  /**\n   *\n   * @type {MyObjectClassDto.Profile}\n   **/\n  set profile(value: InstanceType<typeof MyObjectClassDto.Profile>) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof MyObjectClassDto.Profile) {\n      this.#profile = value;\n    } else {\n      this.#profile = new MyObjectClassDto.Profile(value);\n    }\n  }\n  setProfile(value: InstanceType<typeof MyObjectClassDto.Profile>) {\n    this.profile = value;\n    return this;\n  }\n  /**\n   * The base class definition for profile\n   **/\n  static Profile = class Profile {\n    /**\n     *\n     * @type {string}\n     **/\n    #firstName: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get firstName() {\n      return this.#firstName;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set firstName(value: string) {\n      this.#firstName = String(value);\n    }\n    setFirstName(value: string) {\n      this.firstName = value;\n      return this;\n    }\n    /**\n     *\n     * @type {number}\n     **/\n    #age: number = 0;\n    /**\n     *\n     * @returns {number}\n     **/\n    get age() {\n      return this.#age;\n    }\n    /**\n     *\n     * @type {number}\n     **/\n    set age(value: number) {\n      const correctType = typeof value === "number";\n      const parsedValue = correctType ? value : Number(value);\n      if (!Number.isNaN(parsedValue)) {\n        this.#age = parsedValue;\n      }\n    }\n    setAge(value: number) {\n      this.age = value;\n      return this;\n    }\n    constructor(data: unknown = undefined) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj: unknown) {\n      const g = globalThis as any;\n      const isBuffer =\n        typeof g.Buffer !== "undefined" &&\n        typeof g.Buffer.isBuffer === "function" &&\n        g.Buffer.isBuffer(obj);\n      const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Profile>;\n      if (d.firstName !== undefined) {\n        this.firstName = d.firstName;\n      }\n      if (d.age !== undefined) {\n        this.age = d.age;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        firstName: this.#firstName,\n        age: this.#age,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        firstName: "firstName",\n        age: "age",\n      };\n    }\n    /**\n     * Creates an instance of MyObjectClassDto.Profile, and possibleDtoObject\n     * needs to satisfy the type requirement fully, otherwise typescript compile would\n     * be complaining.\n     **/\n    static from(possibleDtoObject: MyObjectClassDtoType.ProfileType) {\n      return new MyObjectClassDto.Profile(possibleDtoObject);\n    }\n    /**\n     * Creates an instance of MyObjectClassDto.Profile, and partialDtoObject\n     * needs to satisfy the type, but partially, and rest of the content would\n     * be constructed according to data types and nullability.\n     **/\n    static with(\n      partialDtoObject: PartialDeep<MyObjectClassDtoType.ProfileType>,\n    ) {\n      return new MyObjectClassDto.Profile(partialDtoObject);\n    }\n    copyWith(\n      partial: PartialDeep<MyObjectClassDtoType.ProfileType>,\n    ): InstanceType<typeof MyObjectClassDto.Profile> {\n      return new MyObjectClassDto.Profile({ ...this.toJSON(), ...partial });\n    }\n    clone(): InstanceType<typeof MyObjectClassDto.Profile> {\n      return new MyObjectClassDto.Profile(this.toJSON());\n    }\n  };\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      this.#lateInitFields();\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyObjectClassDto>;\n    if (d.profile !== undefined) {\n      this.profile = d.profile;\n    }\n    this.#lateInitFields(data);\n  }\n  /**\n   * These are the class instances, which need to be initialised, regardless of the constructor incoming data\n   **/\n  #lateInitFields(data = {}) {\n    const d = data as Partial<MyObjectClassDto>;\n    if (!(d.profile instanceof MyObjectClassDto.Profile)) {\n      this.profile = new MyObjectClassDto.Profile(d.profile || {});\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      profile: this.#profile,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      profile$: "profile",\n      get profile() {\n        return withPrefix("profile", MyObjectClassDto.Profile.Fields);\n      },\n    };\n  }\n  /**\n   * Creates an instance of MyObjectClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyObjectClassDtoType) {\n    return new MyObjectClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyObjectClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyObjectClassDtoType>) {\n    return new MyObjectClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyObjectClassDtoType>,\n  ): InstanceType<typeof MyObjectClassDto> {\n    return new MyObjectClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyObjectClassDto> {\n    return new MyObjectClassDto(this.toJSON());\n  }\n}\nexport abstract class MyObjectClassDtoFactory {\n  abstract create(data: unknown): MyObjectClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myObjectClassDto\n **/\nexport type MyObjectClassDtoType = {\n  /**\n   *\n   * @type {MyObjectClassDtoType.ProfileType}\n   **/\n  profile: MyObjectClassDtoType.ProfileType;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyObjectClassDtoType {\n  /**\n   * The base type definition for profileType\n   **/\n  export type ProfileType = {\n    /**\n     *\n     * @type {string}\n     **/\n    firstName: string;\n    /**\n     *\n     * @type {number}\n     **/\n    age: number;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace ProfileType {}\n}\n\n'})}),"\n",(0,a.jsx)(e.p,{children:"Nullable version:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:"name: MyObjectClass\nfields:\n  - name: optionalProfile\n    type: object?\n    fields:\n      - name: lastName\n        type: string\n\n"})}),"\n",(0,a.jsxs)(e.p,{children:["Defaults to ",(0,a.jsx)(e.code,{children:"undefined"}),", but you can assign an object with required child fields or ",(0,a.jsx)(e.code,{children:"null"}),"."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-ts",children:'import { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for myObjectClassDto\n **/\nexport class MyObjectClassDto {\n  /**\n   *\n   * @type {MyObjectClassDto.OptionalProfile}\n   **/\n  #optionalProfile?:\n    | InstanceType<typeof MyObjectClassDto.OptionalProfile>\n    | null\n    | undefined\n    | null = undefined;\n  /**\n   *\n   * @returns {MyObjectClassDto.OptionalProfile}\n   **/\n  get optionalProfile() {\n    return this.#optionalProfile;\n  }\n  /**\n   *\n   * @type {MyObjectClassDto.OptionalProfile}\n   **/\n  set optionalProfile(\n    value:\n      | InstanceType<typeof MyObjectClassDto.OptionalProfile>\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof MyObjectClassDto.OptionalProfile) {\n      this.#optionalProfile = value;\n    } else {\n      this.#optionalProfile = new MyObjectClassDto.OptionalProfile(value);\n    }\n  }\n  setOptionalProfile(\n    value:\n      | InstanceType<typeof MyObjectClassDto.OptionalProfile>\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    this.optionalProfile = value;\n    return this;\n  }\n  /**\n   * The base class definition for optionalProfile\n   **/\n  static OptionalProfile = class OptionalProfile {\n    /**\n     *\n     * @type {string}\n     **/\n    #lastName: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get lastName() {\n      return this.#lastName;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set lastName(value: string) {\n      this.#lastName = String(value);\n    }\n    setLastName(value: string) {\n      this.lastName = value;\n      return this;\n    }\n    constructor(data: unknown = undefined) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj: unknown) {\n      const g = globalThis as any;\n      const isBuffer =\n        typeof g.Buffer !== "undefined" &&\n        typeof g.Buffer.isBuffer === "function" &&\n        g.Buffer.isBuffer(obj);\n      const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<OptionalProfile>;\n      if (d.lastName !== undefined) {\n        this.lastName = d.lastName;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        lastName: this.#lastName,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        lastName: "lastName",\n      };\n    }\n    /**\n     * Creates an instance of MyObjectClassDto.OptionalProfile, and possibleDtoObject\n     * needs to satisfy the type requirement fully, otherwise typescript compile would\n     * be complaining.\n     **/\n    static from(possibleDtoObject: MyObjectClassDtoType.OptionalProfileType) {\n      return new MyObjectClassDto.OptionalProfile(possibleDtoObject);\n    }\n    /**\n     * Creates an instance of MyObjectClassDto.OptionalProfile, and partialDtoObject\n     * needs to satisfy the type, but partially, and rest of the content would\n     * be constructed according to data types and nullability.\n     **/\n    static with(\n      partialDtoObject: PartialDeep<MyObjectClassDtoType.OptionalProfileType>,\n    ) {\n      return new MyObjectClassDto.OptionalProfile(partialDtoObject);\n    }\n    copyWith(\n      partial: PartialDeep<MyObjectClassDtoType.OptionalProfileType>,\n    ): InstanceType<typeof MyObjectClassDto.OptionalProfile> {\n      return new MyObjectClassDto.OptionalProfile({\n        ...this.toJSON(),\n        ...partial,\n      });\n    }\n    clone(): InstanceType<typeof MyObjectClassDto.OptionalProfile> {\n      return new MyObjectClassDto.OptionalProfile(this.toJSON());\n    }\n  };\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<MyObjectClassDto>;\n    if (d.optionalProfile !== undefined) {\n      this.optionalProfile = d.optionalProfile;\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      optionalProfile: this.#optionalProfile,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      optionalProfile$: "optionalProfile",\n      get optionalProfile() {\n        return withPrefix(\n          "optionalProfile",\n          MyObjectClassDto.OptionalProfile.Fields,\n        );\n      },\n    };\n  }\n  /**\n   * Creates an instance of MyObjectClassDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: MyObjectClassDtoType) {\n    return new MyObjectClassDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of MyObjectClassDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: PartialDeep<MyObjectClassDtoType>) {\n    return new MyObjectClassDto(partialDtoObject);\n  }\n  copyWith(\n    partial: PartialDeep<MyObjectClassDtoType>,\n  ): InstanceType<typeof MyObjectClassDto> {\n    return new MyObjectClassDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof MyObjectClassDto> {\n    return new MyObjectClassDto(this.toJSON());\n  }\n}\nexport abstract class MyObjectClassDtoFactory {\n  abstract create(data: unknown): MyObjectClassDto;\n}\ntype PartialDeep<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<PartialDeep<U>>\n    : T[P] extends object\n      ? PartialDeep<T[P]>\n      : T[P];\n};\n/**\n * The base type definition for myObjectClassDto\n **/\nexport type MyObjectClassDtoType = {\n  /**\n   *\n   * @type {MyObjectClassDtoType.OptionalProfileType}\n   **/\n  optionalProfile?: MyObjectClassDtoType.OptionalProfileType;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace MyObjectClassDtoType {\n  /**\n   * The base type definition for optionalProfileType\n   **/\n  export type OptionalProfileType = {\n    /**\n     *\n     * @type {string}\n     **/\n    lastName: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace OptionalProfileType {}\n}\n\n'})})]})}function f(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);