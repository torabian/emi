"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[487],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9382:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>m,frontMatter:()=>c,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"js/emi-object","title":"Javascript object generation","description":"Every request body, request response, message on web socket, entity, dto in Emi are called \'object\'. The object is generated based on","source":"@site/docs/js/emi-object.mdx","sourceDirName":"js","slug":"/js/emi-object","permalink":"/emi/docs/js/emi-object","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-object.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Javascript(Type?) Compiler","permalink":"/emi/docs/js/js-intro"},"next":{"title":"Class fields in depth","permalink":"/emi/docs/js/emi-fields-in-depth"}}');var i=t(4848),r=t(8453),o=t(6540);class a{str="";num=0;obj={};arr=[];setStr(e){this.str="string"==typeof e?e:String(e)}getStr(){return this.str}setNum(e){if("number"==typeof e)this.num=e;else{const n=Number(e);this.num=isNaN(n)?0:n}}getNum(){return this.num}setObj(e){this.obj="object"!=typeof e||Array.isArray(e)?{value:e}:e}getObj(){return this.obj}setArr(e){this.arr=Array.isArray(e)?e:[e]}getArr(){return this.arr}}function l(){const[e,n]=(0,o.useState)(1e5),[t,s]=(0,o.useState)(null),r=`// simple object\nconst obj: any = {};\nfor (let i = 0; i < ${e}; i++) {\n  obj.str = "Hello";\n  obj.num = 42;\n  obj.obj = { k: "v" };\n  obj.arr = [1, 2, 3];\n  const x1 = obj.str;\n  const x2 = obj.num;\n  const x3 = obj.obj;\n  const x4 = obj.arr;\n}\n\n// class object\nconst o = new TestClass();\nfor (let i = 0; i < ${e}; i++) {\n  o.setStr("Hello");\n  o.setNum(42);\n  o.setObj({ k: "v" });\n  o.setArr([1, 2, 3]);\n  const x1 = o.getStr();\n  const x2 = o.getNum();\n  const x3 = o.getObj();\n  const x4 = o.getArr();\n}`;return(0,i.jsxs)("div",{className:"p-4 space-y-4",children:[(0,i.jsxs)("div",{className:"flex gap-2 items-center",children:[(0,i.jsx)("input",{type:"number",className:"border p-2 rounded",value:e,onChange:e=>n(Number(e.target.value))}),(0,i.jsx)("button",{onClick:()=>{const n={};let t=performance.now();for(let s=0;s<e;s++){n.str="Hello",n.num=42,n.obj={k:"v"},n.arr=[1,2,3];n.str,n.num,n.obj,n.arr}let i=performance.now();const r=i-t,o=new a;t=performance.now();for(let s=0;s<e;s++){o.setStr("Hello"),o.setNum(42),o.setObj({k:"v"}),o.setArr([1,2,3]);o.getStr(),o.getNum(),o.getObj(),o.getArr()}i=performance.now();s({simple:r,classBased:i-t})},className:"px-4 py-2 bg-blue-600 text-white rounded",children:"Run"})]}),t&&(0,i.jsxs)("div",{className:"space-y-2",children:[(0,i.jsxs)("div",{children:["Object property: ",t.simple.toFixed(2)," ms"]}),(0,i.jsxs)("div",{children:["Class get/set: ",t.classBased.toFixed(2)," ms"]})]}),(0,i.jsx)("pre",{className:"bg-gray-100 p-3 rounded overflow-x-auto text-sm",children:r})]})}const c={sidebar_position:3},d="Javascript object generation",u={},h=[{value:"Javascript classes vs objects",id:"javascript-classes-vs-objects",level:2},{value:"Problems with plain types",id:"problems-with-plain-types",level:3},{value:"Solution: Use Classes",id:"solution-use-classes",level:3},{value:"Performance and usage concerns",id:"performance-and-usage-concerns",level:2},{value:"Comparing the performance",id:"comparing-the-performance",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"javascript-object-generation",children:"Javascript object generation"})}),"\n",(0,i.jsx)(n.p,{children:"Every request body, request response, message on web socket, entity, dto in Emi are called 'object'. The object is generated based on\nfields array, which can be nested, of course. Emi uses the same function for generting different type of classes."}),"\n",(0,i.jsx)(n.h2,{id:"javascript-classes-vs-objects",children:"Javascript classes vs objects"}),"\n",(0,i.jsx)(n.p,{children:"When working with APIs, it\u2019s tempting to just define a TypeScript type and fetch data. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'type Post = { userId: number; id: number; title: string; body: string };\n\nasync function fetchPost(id: number): Promise<Post> {\n  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);\n  return res.json();\n}\n\n// Example usage\nfetchPost(1).then(post => {\n  console.log("Title:", post.title);\n});\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"This looks fine at first glance, but it has some important problems:"}),"\n",(0,i.jsx)(n.h3,{id:"problems-with-plain-types",children:"Problems with plain types"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Backend drift\nThe backend may evolve over time. Fields might be renamed, removed, or added. Your TypeScript types won\u2019t catch this at runtime \u2014 they only exist at compile time."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["No defaults\nIf the backend omits a field, you\u2019ll end up with ",(0,i.jsx)(n.code,{children:"undefined"}),". There\u2019s no way to guarantee initialized values, which makes your code brittle."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Runtime unsafety\nEven if TypeScript says everything is fine, the actual JSON from the server might be malformed or missing required fields. TypeScript does not validate data at runtime."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"solution-use-classes",children:"Solution: Use Classes"}),"\n",(0,i.jsxs)(n.p,{children:["By wrapping responses into ",(0,i.jsx)(n.strong,{children:"classes"}),", we get:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Defaults for missing fields"}),"\n",(0,i.jsx)(n.li,{children:"Runtime-safe construction of objects"}),"\n",(0,i.jsx)(n.li,{children:"A clean place for helper methods"}),"\n",(0,i.jsx)(n.li,{children:"Extending them and embed the extra logic in single place rather than functions scattered across the app."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Take a look at the rewritten mechanism, this time using classes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'class Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n\n  constructor(data: Partial<Post>) {\n    this.userId = data.userId ?? 0;\n    this.id = data.id ?? 0;\n    this.title = data.title ?? "Untitled";\n    this.body = data.body ?? "";\n  }\n\n  static async fetch(id: number): Promise<Post> {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);\n    const json = await res.json();\n    return new Post(json);\n  }\n\n  shortBody(): string {\n    return this.body.slice(0, 50) + "...";\n  }\n}\n\n// Usage\n(async () => {\n  const post = await Post.fetch(1);\n  console.log("Title:", post.title);\n  console.log("Preview:", post.shortBody());\n})();\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now, this is much more reliable code instead of just typing them, you almost never get undefined. But still, writing that manually\nis a hassle, and type checking and other tools might be lost. Now, let's take a look how this could be generated using Emi js compiler:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- name: userId\n  type: int64\n- name: id\n  type: int64\n- name: title\n  type: string\n- name: body\n  type: string\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"And Emi compiler would generate such shopisticated details (content is a bit long but worth to take a look at it.)\nEmi compiler generates ts type and, class, with full getter, setters and validators for each field."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'/**\n * The base class definition for anonymouse\n **/\n\nexport class Anonymouse {\n  /**\n   *\n   * @type {number}\n   **/\n  #userId = 0;\n  /**\n   *\n   * @returns {number}\n   **/\n  get userId() {\n    return this[`#userId`];\n  }\n\n  /**\n   *\n   * @type {number}\n   **/\n\n  set userId(value) {\n    const correctType = typeof value === "number";\n    this["#userId"] = correctType ? value : Number(value);\n  }\n\n  setUserId(value) {\n    this["userId"] = value;\n\n    return this;\n  }\n\n  /**\n   *\n   * @type {number}\n   **/\n  #id = 0;\n  /**\n   *\n   * @returns {number}\n   **/\n  get id() {\n    return this[`#id`];\n  }\n\n  /**\n   *\n   * @type {number}\n   **/\n\n  set id(value) {\n    const correctType = typeof value === "number";\n    this["#id"] = correctType ? value : Number(value);\n  }\n\n  setId(value) {\n    this["id"] = value;\n\n    return this;\n  }\n\n  /**\n   *\n   * @type {string}\n   **/\n  #title = "";\n  /**\n   *\n   * @returns {string}\n   **/\n  get title() {\n    return this[`#title`];\n  }\n\n  /**\n   *\n   * @type {string}\n   **/\n\n  set title(value) {\n    const correctType = typeof value === "string";\n    this["#title"] = correctType ? value : "" + value;\n  }\n\n  setTitle(value) {\n    this["title"] = value;\n\n    return this;\n  }\n\n  /**\n   *\n   * @type {string}\n   **/\n  #body = "";\n  /**\n   *\n   * @returns {string}\n   **/\n  get body() {\n    return this[`#body`];\n  }\n\n  /**\n   *\n   * @type {string}\n   **/\n\n  set body(value) {\n    const correctType = typeof value === "string";\n    this["#body"] = correctType ? value : "" + value;\n  }\n\n  setBody(value) {\n    this["body"] = value;\n\n    return this;\n  }\n\n  constructor(data) {\n    const d = data as Partial<Anonymouse>;\n\n    if (d[`userId`] !== undefined) {\n      this.userId = d[`#userId`];\n    }\n\n    if (d[`id`] !== undefined) {\n      this.id = d[`#id`];\n    }\n\n    if (d[`title`] !== undefined) {\n      this.title = d[`#title`];\n    }\n\n    if (d[`body`] !== undefined) {\n      this.body = d[`#body`];\n    }\n  }\n}\n\n/**\n * The base type definition for anonymouse\n **/\n\nexport type AnonymouseType = {\n  /**\n   *\n   * @type {number}\n   **/\n  userId?: number;\n\n  /**\n   *\n   * @type {number}\n   **/\n  id?: number;\n\n  /**\n   *\n   * @type {string}\n   **/\n  title?: string;\n\n  /**\n   *\n   * @type {string}\n   **/\n  body?: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace AnonymouseType {}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you see, there is a lot of details handled in such object generation, to make sure"}),"\n",(0,i.jsx)(n.p,{children:"the data integrity is kept in perfect level both in compile time and run time."}),"\n",(0,i.jsx)(n.h2,{id:"performance-and-usage-concerns",children:"Performance and usage concerns"}),"\n",(0,i.jsx)(n.p,{children:"Generating such classes is very common on most programming languages, but in javascript it might be a bit of concern,\nmainly for following reasons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Using getField and setField functions, is slower than directly accessing .field property of an object."}),"\n",(0,i.jsx)(n.li,{children:"Setting value using js path, such as set('field.user.address[0].stree', 'New street') might be compromised"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"comparing-the-performance",children:"Comparing the performance"}),"\n",(0,i.jsx)(n.p,{children:"Let's make an interactive comparison, how slower it would be and you'll be suprised getters and setters are\nfaster in some environments."}),"\n",(0,i.jsx)(n.p,{children:"It looks odd at first, but the reason getter/setter sometimes beats direct property access comes down to how modern\nJavaScript engines optimize. A plain object can change shape at any time, which makes the engine cautious and may\ncause de-optimizations during tight loops. By contrast, a class with fixed methods has a stable shape, so the JIT\ncompiler can inline and optimize those calls very aggressively. On top of that, microbenchmarks can be misleading:\nif values aren\u2019t used in a meaningful way, the engine may partially skip or simplify the operations.\nIn practice, the difference is just a few milliseconds across millions of iterations, so for real-world\ncode, both approaches are effectively free.\nI prefer this response"}),"\n",(0,i.jsx)(l,{}),"\n",(0,i.jsx)(n.p,{children:"As you might see, the numbers are very close, and in real life, you would not call millions of times\none after each other a javascript setter. Hence, Emi compiler extra checks make sense to bring the safety\ninto the code base."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);