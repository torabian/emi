"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[627],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},9988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"emi-actions","title":"Emi Actions","description":"Actions is a crucial part of almost every software. Actions in empty basically functions, which get an input, and return output. They can be correspond to \'controllers\'","source":"@site/docs/emi-actions.mdx","sourceDirName":".","slug":"/emi-actions","permalink":"/emi/docs/emi-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/emi-actions.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Emi definitions","permalink":"/emi/docs/emi-module-spec"},"next":{"title":"Javascript(Type?) Compiler","permalink":"/emi/docs/js/js-intro"}}');var s=t(4848),o=t(8453);const r={sidebar_position:4},d="Emi Actions",c={},a=[{value:"Defining actions overview",id:"defining-actions-overview",level:2},{value:"Actions properties",id:"actions-properties",level:2},{value:"Action methods",id:"action-methods",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"emi-actions",children:"Emi Actions"})}),"\n",(0,s.jsx)(n.p,{children:"Actions is a crucial part of almost every software. Actions in empty basically functions, which get an input, and return output. They can be correspond to 'controllers'\nin traditional API development, each action is basically an endpoint. Actions also can be called from other contexts than http, for example from cli."}),"\n",(0,s.jsx)(n.p,{children:"For most cases, actions help you to define 'get', 'post' ... actions, as well as 'reactive' which is a websocket, and 'sse', which stands for server side event."}),"\n",(0,s.jsx)(n.h2,{id:"defining-actions-overview",children:"Defining actions overview"}),"\n",(0,s.jsx)(n.p,{children:"As mentioned in the general definitions, actions is a part of module, which is an array, and allows developer to define multiple actions, as items. Each action must have a name, and that's basically enough for it to be compiled by different sub compilers in Emi project."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'name: sampleModule\nactions:\n  - name: getSinglePost\n    url: https://jsonplaceholder.typicode.com/posts/:id\n    cliName: get-single-post\n    method: get\n    description: Get\'s an specific post from the endpoint\n    out:\n      fields:\n        - name: userId\n          type: int64\n        - name: id\n          type: int64\n        - name: title\n          type: string\n        - name: body\n          type: string\n  - name: sampleSse\n    url: http://localhost:3000/stream\n    method: get\n    description: SSE Sample\n    out:\n      fields:\n        - name: message\n          type: string\n  - name: webSocketOrgEcho\n    url: "wss://echo.websocket.org/.ws"\n    method: reactive\n    description: Websocket.org eco server, to send a json and recieve back\n    in:\n      fields:\n        - name: firstName\n          type: string\n        - name: lastName\n          type: string\n    out:\n      fields:\n        - name: lastName\n          type: string\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"actions-properties",children:"Actions properties"}),"\n",(0,s.jsx)(n.p,{children:"Each action within a module needs to have a camel case name, and needs to be unique. The other properties are optional. Nevertheless, 'in', 'out', 'method' and 'url' are the most common properties of an action which you'll set as a developer.\r\nDepending on your use case, you might not need all features, or they might not be used by the sub compilers."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"name"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"General name of the action used for generating code and CLI commands"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cliName"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Overrides the CLI action name if specified otherwise defaults to Name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"actionAliases"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"array"})}),(0,s.jsx)(n.td,{children:"CLI command aliases for shorter action names"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"url"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"HTTP route of the action; if not specified the action is CLI-only"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"method"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"HTTP method type including standard and Emi-specific methods"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"binaryType"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Text by default for websocket"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"qs"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"array"})}),(0,s.jsx)(n.td,{children:"Type-safe query parameters for CLI and HTTP requests"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"description"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Action description used in API specs and documentation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"in"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"undefined"})}),(0,s.jsx)(n.td,{children:"Request body definition similar to HTTP request body"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"undefined"})}),(0,s.jsx)(n.td,{children:"Response body definition similar to HTTP response body"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"action-methods",children:"Action methods"}),"\n",(0,s.jsxs)(n.p,{children:["Emi allows for standard http methods, as well as some extra which will be converted to different protocols.\r\nCurrently supported the actions and methods are the following: ",(0,s.jsx)(n.code,{children:"post"}),", ",(0,s.jsx)(n.code,{children:"patch"}),", ",(0,s.jsx)(n.code,{children:"put"}),", ",(0,s.jsx)(n.code,{children:"get"}),", ",(0,s.jsx)(n.code,{children:"delete"}),", ",(0,s.jsx)(n.code,{children:"webrtc"}),", ",(0,s.jsx)(n.code,{children:"reactive"}),", ",(0,s.jsx)(n.code,{children:"sse"}),". Calling for non-existing method, would resolve to http with the non-standard method."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);