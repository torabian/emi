"use strict";(self.webpackChunkemi_web=self.webpackChunkemi_web||[]).push([[382],{5930:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"js/emi-nullable-object","title":"Nullable object vs non-nullable","description":"Emi definition allows for nullable object vs non-nullable objects. In case an object is not nullable, should always be present and initialised","source":"@site/docs/js/emi-nullable-object.md","sourceDirName":"js","slug":"/js/emi-nullable-object","permalink":"/emi/docs/js/emi-nullable-object","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/emi/tree/main/emi-web/docs/js/emi-nullable-object.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Complex Types in Emi","permalink":"/emi/docs/js/emi-complex-types"},"next":{"title":"emi-nullable-object","permalink":"/emi/docs/js/emi-nullable-object"}}');var s=t(4848),a=t(8453);const i={sidebar_position:4},l="Nullable object vs non-nullable",r={},c=[];function p(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nullable-object-vs-non-nullable",children:"Nullable object vs non-nullable"})}),"\n",(0,s.jsx)(n.p,{children:"Emi definition allows for nullable object vs non-nullable objects. In case an object is not nullable, should always be present and initialised\nby the parent class upon instantiation. For types, simply it would indicate that it needs to be present."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"name: nullableResponseAction\nfields:\n  - name: mother\n    type: object\n    description: Mother info should be present\n    fields:\n      - name: firstName\n        type: string\n  - name: father\n    type: object?\n    description: Father name is not essential for some goverment papers.\n    fields:\n      - name: firstName\n        type: string\n  - name: firstUncle\n    type: one\n    target: UncleDto\n    description: Uncle is a separate dto, therefor we use that entity\n  - name: secondUncle\n    type: one?\n    target: UncleDto\n    description: Second uncle is optional\n\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { UncleDto } from "./UncleDto";\nimport { withPrefix } from "./sdk/common/withPrefix";\n/**\n * The base class definition for nullableResponseActionDto\n **/\nexport class NullableResponseActionDto {\n  /**\n   * Mother info should be present\n   * @type {NullableResponseActionDto.Mother}\n   **/\n  #mother!: InstanceType<typeof NullableResponseActionDto.Mother>;\n  /**\n   * Mother info should be present\n   * @returns {NullableResponseActionDto.Mother}\n   **/\n  get mother() {\n    return this.#mother;\n  }\n  /**\n   * Mother info should be present\n   * @type {NullableResponseActionDto.Mother}\n   **/\n  set mother(value: InstanceType<typeof NullableResponseActionDto.Mother>) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof NullableResponseActionDto.Mother) {\n      this.#mother = value;\n    } else {\n      this.#mother = new NullableResponseActionDto.Mother(value);\n    }\n  }\n  setMother(value: InstanceType<typeof NullableResponseActionDto.Mother>) {\n    this.mother = value;\n    return this;\n  }\n  /**\n   * Father name is not essential for some goverment papers.\n   * @type {NullableResponseActionDto.Father}\n   **/\n  #father?:\n    | InstanceType<typeof NullableResponseActionDto.Father>\n    | null\n    | undefined\n    | null = undefined;\n  /**\n   * Father name is not essential for some goverment papers.\n   * @returns {NullableResponseActionDto.Father}\n   **/\n  get father() {\n    return this.#father;\n  }\n  /**\n   * Father name is not essential for some goverment papers.\n   * @type {NullableResponseActionDto.Father}\n   **/\n  set father(\n    value:\n      | InstanceType<typeof NullableResponseActionDto.Father>\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof NullableResponseActionDto.Father) {\n      this.#father = value;\n    } else {\n      this.#father = new NullableResponseActionDto.Father(value);\n    }\n  }\n  setFather(\n    value:\n      | InstanceType<typeof NullableResponseActionDto.Father>\n      | null\n      | undefined\n      | null\n      | undefined,\n  ) {\n    this.father = value;\n    return this;\n  }\n  /**\n   * Uncle is a separate dto, therefor we use that entity\n   * @type {UncleDto}\n   **/\n  #firstUncle!: UncleDto;\n  /**\n   * Uncle is a separate dto, therefor we use that entity\n   * @returns {UncleDto}\n   **/\n  get firstUncle() {\n    return this.#firstUncle;\n  }\n  /**\n   * Uncle is a separate dto, therefor we use that entity\n   * @type {UncleDto}\n   **/\n  set firstUncle(value: UncleDto) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof UncleDto) {\n      this.#firstUncle = value;\n    } else {\n      this.#firstUncle = new UncleDto(value);\n    }\n  }\n  setFirstUncle(value: UncleDto) {\n    this.firstUncle = value;\n    return this;\n  }\n  /**\n   * Second uncle is optional\n   * @type {UncleDto}\n   **/\n  #secondUncle?: UncleDto | null = undefined;\n  /**\n   * Second uncle is optional\n   * @returns {UncleDto}\n   **/\n  get secondUncle() {\n    return this.#secondUncle;\n  }\n  /**\n   * Second uncle is optional\n   * @type {UncleDto}\n   **/\n  set secondUncle(value: UncleDto | null | undefined) {\n    // For objects, the sub type needs to always be instance of the sub class.\n    if (value instanceof UncleDto) {\n      this.#secondUncle = value;\n    } else {\n      this.#secondUncle = new UncleDto(value);\n    }\n  }\n  setSecondUncle(value: UncleDto | null | undefined) {\n    this.secondUncle = value;\n    return this;\n  }\n  /**\n   * The base class definition for mother\n   **/\n  static Mother = class Mother {\n    /**\n     *\n     * @type {string}\n     **/\n    #firstName: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get firstName() {\n      return this.#firstName;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set firstName(value: string) {\n      const correctType = typeof value === "string";\n      this.#firstName = correctType ? value : "" + value;\n    }\n    setFirstName(value: string) {\n      this.firstName = value;\n      return this;\n    }\n    constructor(data: unknown = undefined) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj: unknown) {\n      const g = globalThis as any;\n      const isBuffer =\n        typeof g.Buffer !== "undefined" &&\n        typeof g.Buffer.isBuffer === "function" &&\n        g.Buffer.isBuffer(obj);\n      const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Mother>;\n      if (d.firstName !== undefined) {\n        this.firstName = d.firstName;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        firstName: this.#firstName,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        firstName: "firstName",\n      };\n    }\n    /**\n     * Creates an instance of NullableResponseActionDto.Mother, and possibleDtoObject\n     * needs to satisfy the type requirement fully, otherwise typescript compile would\n     * be complaining.\n     **/\n    static from(possibleDtoObject: NullableResponseActionDtoType.MotherType) {\n      return new NullableResponseActionDto.Mother(possibleDtoObject);\n    }\n    /**\n     * Creates an instance of NullableResponseActionDto.Mother, and partialDtoObject\n     * needs to satisfy the type, but partially, and rest of the content would\n     * be constructed according to data types and nullability.\n     **/\n    static with(\n      partialDtoObject: Partial<NullableResponseActionDtoType.MotherType>,\n    ) {\n      return new NullableResponseActionDto.Mother(partialDtoObject);\n    }\n    copyWith(\n      partial: Partial<NullableResponseActionDtoType.MotherType>,\n    ): InstanceType<typeof NullableResponseActionDto.Mother> {\n      return new NullableResponseActionDto.Mother({\n        ...this.toJSON(),\n        ...partial,\n      });\n    }\n    clone(): InstanceType<typeof NullableResponseActionDto.Mother> {\n      return new NullableResponseActionDto.Mother(this.toJSON());\n    }\n  };\n  /**\n   * The base class definition for father\n   **/\n  static Father = class Father {\n    /**\n     *\n     * @type {string}\n     **/\n    #firstName: string = "";\n    /**\n     *\n     * @returns {string}\n     **/\n    get firstName() {\n      return this.#firstName;\n    }\n    /**\n     *\n     * @type {string}\n     **/\n    set firstName(value: string) {\n      const correctType = typeof value === "string";\n      this.#firstName = correctType ? value : "" + value;\n    }\n    setFirstName(value: string) {\n      this.firstName = value;\n      return this;\n    }\n    constructor(data: unknown = undefined) {\n      if (data === null || data === undefined) {\n        return;\n      }\n      if (typeof data === "string") {\n        this.applyFromObject(JSON.parse(data));\n      } else if (this.#isJsonAppliable(data)) {\n        this.applyFromObject(data);\n      } else {\n        throw new Error(\n          "Instance cannot be created on an unknown value, check the content being passed. got: " +\n            typeof data,\n        );\n      }\n    }\n    #isJsonAppliable(obj: unknown) {\n      const g = globalThis as any;\n      const isBuffer =\n        typeof g.Buffer !== "undefined" &&\n        typeof g.Buffer.isBuffer === "function" &&\n        g.Buffer.isBuffer(obj);\n      const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n      return (\n        obj &&\n        typeof obj === "object" &&\n        !Array.isArray(obj) &&\n        !isBuffer &&\n        !(obj instanceof ArrayBuffer) &&\n        !isBlob\n      );\n    }\n    /**\n     * casts the fields of a javascript object into the class properties one by one\n     **/\n    applyFromObject(data = {}) {\n      const d = data as Partial<Father>;\n      if (d.firstName !== undefined) {\n        this.firstName = d.firstName;\n      }\n    }\n    /**\n     *\tSpecial toJSON override, since the field are private,\n     *\tJson stringify won\'t see them unless we mention it explicitly.\n     **/\n    toJSON() {\n      return {\n        firstName: this.#firstName,\n      };\n    }\n    toString() {\n      return JSON.stringify(this);\n    }\n    static get Fields() {\n      return {\n        firstName: "firstName",\n      };\n    }\n    /**\n     * Creates an instance of NullableResponseActionDto.Father, and possibleDtoObject\n     * needs to satisfy the type requirement fully, otherwise typescript compile would\n     * be complaining.\n     **/\n    static from(possibleDtoObject: NullableResponseActionDtoType.FatherType) {\n      return new NullableResponseActionDto.Father(possibleDtoObject);\n    }\n    /**\n     * Creates an instance of NullableResponseActionDto.Father, and partialDtoObject\n     * needs to satisfy the type, but partially, and rest of the content would\n     * be constructed according to data types and nullability.\n     **/\n    static with(\n      partialDtoObject: Partial<NullableResponseActionDtoType.FatherType>,\n    ) {\n      return new NullableResponseActionDto.Father(partialDtoObject);\n    }\n    copyWith(\n      partial: Partial<NullableResponseActionDtoType.FatherType>,\n    ): InstanceType<typeof NullableResponseActionDto.Father> {\n      return new NullableResponseActionDto.Father({\n        ...this.toJSON(),\n        ...partial,\n      });\n    }\n    clone(): InstanceType<typeof NullableResponseActionDto.Father> {\n      return new NullableResponseActionDto.Father(this.toJSON());\n    }\n  };\n  constructor(data: unknown = undefined) {\n    if (data === null || data === undefined) {\n      this.#lateInitFields();\n      return;\n    }\n    if (typeof data === "string") {\n      this.applyFromObject(JSON.parse(data));\n    } else if (this.#isJsonAppliable(data)) {\n      this.applyFromObject(data);\n    } else {\n      throw new Error(\n        "Instance cannot be created on an unknown value, check the content being passed. got: " +\n          typeof data,\n      );\n    }\n  }\n  #isJsonAppliable(obj: unknown) {\n    const g = globalThis as any;\n    const isBuffer =\n      typeof g.Buffer !== "undefined" &&\n      typeof g.Buffer.isBuffer === "function" &&\n      g.Buffer.isBuffer(obj);\n    const isBlob = typeof g.Blob !== "undefined" && obj instanceof g.Blob;\n    return (\n      obj &&\n      typeof obj === "object" &&\n      !Array.isArray(obj) &&\n      !isBuffer &&\n      !(obj instanceof ArrayBuffer) &&\n      !isBlob\n    );\n  }\n  /**\n   * casts the fields of a javascript object into the class properties one by one\n   **/\n  applyFromObject(data = {}) {\n    const d = data as Partial<NullableResponseActionDto>;\n    if (d.mother !== undefined) {\n      this.mother = d.mother;\n    }\n    if (d.father !== undefined) {\n      this.father = d.father;\n    }\n    if (d.firstUncle !== undefined) {\n      this.firstUncle = d.firstUncle;\n    }\n    if (d.secondUncle !== undefined) {\n      this.secondUncle = d.secondUncle;\n    }\n    this.#lateInitFields(data);\n  }\n  /**\n   * These are the class instances, which need to be initialised, regardless of the constructor incoming data\n   **/\n  #lateInitFields(data = {}) {\n    const d = data as Partial<NullableResponseActionDto>;\n    if (!(d.mother instanceof NullableResponseActionDto.Mother)) {\n      this.mother = new NullableResponseActionDto.Mother(d.mother || {});\n    }\n    if (!(d.firstUncle instanceof UncleDto)) {\n      this.firstUncle = new UncleDto(d.firstUncle || {});\n    }\n  }\n  /**\n   *\tSpecial toJSON override, since the field are private,\n   *\tJson stringify won\'t see them unless we mention it explicitly.\n   **/\n  toJSON() {\n    return {\n      mother: this.#mother,\n      father: this.#father,\n      firstUncle: this.#firstUncle,\n      secondUncle: this.#secondUncle,\n    };\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  static get Fields() {\n    return {\n      mother$: "mother",\n      get mother() {\n        return withPrefix("mother", NullableResponseActionDto.Mother.Fields);\n      },\n      father$: "father",\n      get father() {\n        return withPrefix("father", NullableResponseActionDto.Father.Fields);\n      },\n      firstUncle$: "firstUncle",\n      get firstUncle() {\n        return withPrefix("firstUncle", UncleDto.Fields);\n      },\n      secondUncle: "secondUncle",\n    };\n  }\n  /**\n   * Creates an instance of NullableResponseActionDto, and possibleDtoObject\n   * needs to satisfy the type requirement fully, otherwise typescript compile would\n   * be complaining.\n   **/\n  static from(possibleDtoObject: NullableResponseActionDtoType) {\n    return new NullableResponseActionDto(possibleDtoObject);\n  }\n  /**\n   * Creates an instance of NullableResponseActionDto, and partialDtoObject\n   * needs to satisfy the type, but partially, and rest of the content would\n   * be constructed according to data types and nullability.\n   **/\n  static with(partialDtoObject: Partial<NullableResponseActionDtoType>) {\n    return new NullableResponseActionDto(partialDtoObject);\n  }\n  copyWith(\n    partial: Partial<NullableResponseActionDtoType>,\n  ): InstanceType<typeof NullableResponseActionDto> {\n    return new NullableResponseActionDto({ ...this.toJSON(), ...partial });\n  }\n  clone(): InstanceType<typeof NullableResponseActionDto> {\n    return new NullableResponseActionDto(this.toJSON());\n  }\n}\nexport abstract class NullableResponseActionDtoFactory {\n  abstract create(data: unknown): NullableResponseActionDto;\n}\n/**\n * The base type definition for nullableResponseActionDto\n **/\nexport type NullableResponseActionDtoType = {\n  /**\n   * Mother info should be present\n   * @type {NullableResponseActionDtoType.MotherType}\n   **/\n  mother: NullableResponseActionDtoType.MotherType;\n  /**\n   * Father name is not essential for some goverment papers.\n   * @type {NullableResponseActionDtoType.FatherType}\n   **/\n  father?: NullableResponseActionDtoType.FatherType;\n  /**\n   * Uncle is a separate dto, therefor we use that entity\n   * @type {UncleDto}\n   **/\n  firstUncle: UncleDto;\n  /**\n   * Second uncle is optional\n   * @type {UncleDto}\n   **/\n  secondUncle?: UncleDto;\n};\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace NullableResponseActionDtoType {\n  /**\n   * The base type definition for motherType\n   **/\n  export type MotherType = {\n    /**\n     *\n     * @type {string}\n     **/\n    firstName: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace MotherType {}\n  /**\n   * The base type definition for fatherType\n   **/\n  export type FatherType = {\n    /**\n     *\n     * @type {string}\n     **/\n    firstName: string;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  export namespace FatherType {}\n}\n\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var o=t(6540);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);