---
sidebar_position: 9
---

# Emi array data type
    

Example schema:
```yaml
name: MyArrayClass
fields:
  - name: contacts
    type: array
    fields:
      - name: email
        type: string
      - name: phone
        type: string?

```

- `array` represents a list of items.  
- You must define an `items` field with the child type.  
- Defaults to an empty array `[]` if not specified.  
- `array?` allows `null`/ `undefined`.  
    
```ts
/**
 * The base class definition for myArrayClassDto
 **/

export class MyArrayClassDto {
  /**
   *
   * @type {MyArrayClassDto.Contacts}
   **/
  #contacts: InstanceType<typeof MyArrayClassDto.Contacts>[] = [];
  /**
   *
   * @returns {MyArrayClassDto.Contacts}
   **/
  get contacts() {
    return this[`#contacts`];
  }

  /**
   *
   * @type {MyArrayClassDto.Contacts}
   **/

  set contacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {
    // For arrays, you only can pass arrays to the object
    if (!Array.isArray(value)) {
      return;
    }
    if (value.length > 0 && value[0] instanceof MyArrayClassDto.Contacts) {
      this["#contacts"] = value;
    } else {
      this["#contacts"] = value.map(
        (item) => new MyArrayClassDto.Contacts(item),
      );
    }
  }

  setContacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {
    this["contacts"] = value;

    return this;
  }

  /**
   * The base class definition for contacts
   **/

  static Contacts = class Contacts {
    /**
     *
     * @type {string}
     **/
    #email: string = "";
    /**
     *
     * @returns {string}
     **/
    get email() {
      return this[`#email`];
    }

    /**
     *
     * @type {string}
     **/

    set email(value: string) {
      const correctType = typeof value === "string";
      this["#email"] = correctType ? value : "" + value;
    }

    setEmail(value: string) {
      this["email"] = value;

      return this;
    }

    /**
     *
     * @type {string}
     **/
    #phone?: string | null = undefined;
    /**
     *
     * @returns {string}
     **/
    get phone() {
      return this[`#phone`];
    }

    /**
     *
     * @type {string}
     **/

    set phone(value: string) {
      const correctType =
        typeof value === "string" || value === undefined || value === null;
      this["#phone"] = correctType ? value : "" + value;
    }

    setPhone(value: string) {
      this["phone"] = value;

      return this;
    }

    constructor(data: unknown) {
      const d = data as Partial<Contacts>;

      if (d[`email`] !== undefined) {
        this.email = d[`#email`];
      }

      if (d[`phone`] !== undefined) {
        this.phone = d[`#phone`];
      }
    }
  };

  constructor(data: unknown) {
    const d = data as Partial<MyArrayClassDto>;

    if (d[`contacts`] !== undefined) {
      this.contacts = d[`#contacts`];
    }
  }
}

export abstract class MyArrayClassDtoFactory {
  abstract create(data: unknown): MyArrayClassDto;
}

/**
 * The base type definition for myArrayClassDto
 **/

export type MyArrayClassDtoType = {
  /**
   *
   * @type {MyArrayClassDtoType.ContactsType[]}
   **/
  contacts?: MyArrayClassDtoType.ContactsType[];
};

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace MyArrayClassDtoType {
  /**
   * The base type definition for contactsType
   **/

  export type ContactsType = {
    /**
     *
     * @type {string}
     **/
    email?: string;

    /**
     *
     * @type {string}
     **/
    phone?: string;
  };

  // eslint-disable-next-line @typescript-eslint/no-namespace
  export namespace ContactsType {}
}

```

Array of objects:
```yaml
name: MyArrayClass
fields:
  - name: contacts
    type: array
    fields:
      - name: email
        type: string
      - name: phone
        type: string?

```

Arrays can hold primitive types or nested objects.
    
```ts
/**
 * The base class definition for myArrayClassDto
 **/

export class MyArrayClassDto {
  /**
   *
   * @type {MyArrayClassDto.Contacts}
   **/
  #contacts: InstanceType<typeof MyArrayClassDto.Contacts>[] = [];
  /**
   *
   * @returns {MyArrayClassDto.Contacts}
   **/
  get contacts() {
    return this[`#contacts`];
  }

  /**
   *
   * @type {MyArrayClassDto.Contacts}
   **/

  set contacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {
    // For arrays, you only can pass arrays to the object
    if (!Array.isArray(value)) {
      return;
    }
    if (value.length > 0 && value[0] instanceof MyArrayClassDto.Contacts) {
      this["#contacts"] = value;
    } else {
      this["#contacts"] = value.map(
        (item) => new MyArrayClassDto.Contacts(item),
      );
    }
  }

  setContacts(value: InstanceType<typeof MyArrayClassDto.Contacts>[]) {
    this["contacts"] = value;

    return this;
  }

  /**
   * The base class definition for contacts
   **/

  static Contacts = class Contacts {
    /**
     *
     * @type {string}
     **/
    #email: string = "";
    /**
     *
     * @returns {string}
     **/
    get email() {
      return this[`#email`];
    }

    /**
     *
     * @type {string}
     **/

    set email(value: string) {
      const correctType = typeof value === "string";
      this["#email"] = correctType ? value : "" + value;
    }

    setEmail(value: string) {
      this["email"] = value;

      return this;
    }

    /**
     *
     * @type {string}
     **/
    #phone?: string | null = undefined;
    /**
     *
     * @returns {string}
     **/
    get phone() {
      return this[`#phone`];
    }

    /**
     *
     * @type {string}
     **/

    set phone(value: string) {
      const correctType =
        typeof value === "string" || value === undefined || value === null;
      this["#phone"] = correctType ? value : "" + value;
    }

    setPhone(value: string) {
      this["phone"] = value;

      return this;
    }

    constructor(data: unknown) {
      const d = data as Partial<Contacts>;

      if (d[`email`] !== undefined) {
        this.email = d[`#email`];
      }

      if (d[`phone`] !== undefined) {
        this.phone = d[`#phone`];
      }
    }
  };

  constructor(data: unknown) {
    const d = data as Partial<MyArrayClassDto>;

    if (d[`contacts`] !== undefined) {
      this.contacts = d[`#contacts`];
    }
  }
}

export abstract class MyArrayClassDtoFactory {
  abstract create(data: unknown): MyArrayClassDto;
}

/**
 * The base type definition for myArrayClassDto
 **/

export type MyArrayClassDtoType = {
  /**
   *
   * @type {MyArrayClassDtoType.ContactsType[]}
   **/
  contacts?: MyArrayClassDtoType.ContactsType[];
};

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace MyArrayClassDtoType {
  /**
   * The base type definition for contactsType
   **/

  export type ContactsType = {
    /**
     *
     * @type {string}
     **/
    email?: string;

    /**
     *
     * @type {string}
     **/
    phone?: string;
  };

  // eslint-disable-next-line @typescript-eslint/no-namespace
  export namespace ContactsType {}
}

```

Nullable version:
```yaml
name: MyArrayClass
fields:
  - name: nullableTags
    type: array?

```

Defaults to `undefined`, but you can assign an array or `null`.
    
```ts
/**
 * The base class definition for myArrayClassDto
 **/

export class MyArrayClassDto {
  /**
   *
   * @type {string}
   **/
  #nullableTags?: string | null = undefined;
  /**
   *
   * @returns {string}
   **/
  get nullableTags() {
    return this[`#nullableTags`];
  }

  /**
   *
   * @type {string}
   **/

  set nullableTags(value: string) {}

  setNullableTags(value: string) {
    this["nullableTags"] = value;

    return this;
  }

  constructor(data: unknown) {
    const d = data as Partial<MyArrayClassDto>;

    if (d[`nullableTags`] !== undefined) {
      this.nullableTags = d[`#nullableTags`];
    }
  }
}

export abstract class MyArrayClassDtoFactory {
  abstract create(data: unknown): MyArrayClassDto;
}

/**
 * The base type definition for myArrayClassDto
 **/

export type MyArrayClassDtoType = {
  /**
   *
   * @type {string}
   **/
  nullableTags?: string;
};

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace MyArrayClassDtoType {}

```